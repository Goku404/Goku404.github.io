<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于博客</title>
    <url>/2021/05/30/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>博客的更新是很有必要的，有两个博客。</p>
<span id="more"></span>

<p>本博客基于 hexo 主题和 github静态页面，非技术流，风格较偏向于流水账 &gt;__&lt; ,。入坑教程:<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a>  </p>
<p>另一个博客基于腾讯云的轻量服务器的wordpress应用，为动态博客。域名还未申请。</p>
<p>7.15</p>
<p>域名的备案也太麻烦了吧。。。。有时间再弄</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux那些命令</title>
    <url>/2021/07/14/Linux%E9%82%A3%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux那些命令-1"><a href="#Linux那些命令-1" class="headerlink" title="Linux那些命令(1)"></a>Linux那些命令(1)</h1><span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf ***.tar.gz filelist     //打包</span><br><span class="line">tar -xvf ***.tar.gz -C 目标文件   //解压</span><br><span class="line">find ./  -regex &quot; .*\.[ch]&quot;     //查找该目录下的所有.c和.h文件</span><br><span class="line">find ./  -regex &quot;.*\.[ch]&quot; -exec tar -zcvf hello.tar.gz &#123;&#125; +   //打包所有.c和.h文件</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(5)</title>
    <url>/2021/07/13/%E5%81%87%E6%9C%9F-5/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/07/12/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><span id="more"></span>

<h2 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h2><p><img src="https://pic.imgdb.cn/item/60ec3d485132923bf8c2230d.gif"></p>
<p>步骤：选中一个key每次都是从左边开始 , 先从它的右边开始遍历，找到比它小的，再从左边找到比它大的。然后作为分界点，左边递归，右边递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = l,last = r,key = a[first];</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[last] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            last ++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[first] = a[last];</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[first] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            first --;</span><br><span class="line">        &#125;</span><br><span class="line">        a[last] = a[first];</span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;</span><br><span class="line">    quick(a,l,first);</span><br><span class="line">    quick(a,first+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h2>]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/09/2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h1><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1 运算符"></a>1 运算符</h2><span id="more"></span>

<ul>
<li><p>单目运算符</p>
<blockquote>
<p>++ – ! ~ 只需要一个操作数</p>
</blockquote>
</li>
<li><p>算术运算符</p>
<blockquote>
<p>++ – + - * / %</p>
</blockquote>
</li>
<li><p>关系运算符</p>
<blockquote>
<p>&lt; &gt;=  &lt;=  !=  ==    </p>
</blockquote>
<p>  <em><strong>①</strong></em>关系运算符连接的表达式叫做 <strong>关系表达式</strong><br>  <em><strong>②</strong></em>,5&gt;4&gt;3这个表达式和数学的5&gt;4&gt;3的含义是不一样的。c语言是（5&gt;4）=1 &gt;3   </p>
</li>
<li><p>逻辑运算符</p>
<blockquote>
<p>! &amp;&amp; ||<br>  优先级: ! &gt; &amp;&amp; &gt; ||  </p>
</blockquote>
<p>  <strong>注</strong><font color = red> c语言运算符是惰性的</font>  例如：<br>  A&amp;&amp;B&amp;&amp;C 只要A为0了，整体就为0了，后面不需要比较了。</p>
</li>
<li><p>条件运算符</p>
<blockquote>
<p>?:  例如：<br>  score &gt; 100?’E’:score&gt;=90?’A’:score&gt;=60?’B’:score&lt;0?’E’:’C’;</p>
</blockquote>
</li>
<li><p>赋值运算符  </p>
<blockquote>
<p>= 优先级直逗号高，排倒数第二  </p>
</blockquote>
<p> <strong>赋值运算符的基本规则：</strong><br> <em><strong>①</strong></em>赋值运算符的<strong>左边</strong>(左操作数)必须是一个<strong>可写的地址</strong>(左值)<br> <em><strong>②</strong></em>一些例子 如：  </p>
</li>
<li><p>逗号运算符</p>
<blockquote>
<p>,  </p>
</blockquote>
<p>  <strong>表达式1</strong>,<strong>表达式2</strong>,….<strong>表达式n</strong>;<br>  <strong>求值顺序</strong>,先计算表达式1的值,再计算表达式2的值….最后计算表达式n<strong>整个逗号表达式的值是表达式n的值</strong></p>
</li>
<li><p>指针运算符(*,&amp;)</p>
</li>
<li><p>求字节数量运算符(sizeof)</p>
</li>
<li><p>分量运算符(结构体)<br><font color = red size = 5> 运算符的优先级</font><br><img src="https://i.loli.net/2021/07/09/mp6rDQEBF7zStdU.jpg" alt="1.jpg"></p>
<h2 id="2、表达式"><a href="#2、表达式" class="headerlink" title="2、表达式"></a>2、表达式</h2><h2 id="3、位运算"><a href="#3、位运算" class="headerlink" title="3、位运算"></a>3、位运算</h2></li>
</ul>
<ul>
<li>&amp; <em><strong>按位与</strong></em><blockquote>
<p>结论:<br>  一个bit位与0进行“按位与”操作,结果为0<br>  一个bit位与1进行“按位与”操作,结果不变</p>
</blockquote>
</li>
<li>|    <em><strong>按位或</strong></em>  <blockquote>
<p>结论:<br>  一个bit位与0进行“按位或”操作,结果不变<br>  一个bit位与1进行“按位或”操作,结果置1</p>
</blockquote>
</li>
<li>^    <em><strong>按位异或</strong></em> <blockquote>
<p>结论:<br>  一个bit位与0进行“按位异或”操作,结果不变<br>  一个bit位与1进行“按位异或”操作,结果反转<br>  例子：<br>  <strong>7</strong>取出整数变量x中第p位开始的n个bit位<br>  <strong>8</strong>将x中第p位开始的n个bit位设置为y(整数变量)中的最右边的n位的值，x的其余各位保持不变<br>  <strong>9</strong>将x中第p位开始的n个bit位取反，其余各位保持不变  </p>
</blockquote>
</li>
<li>~    按位取反   </li>
<li>&lt;&lt; 按位左移  <blockquote>
<p>同右移</p>
</blockquote>
</li>
<li>(&gt;&gt;) 按位右移  <blockquote>
<p>双目运算符,所有的bit位整体向右边移动a&gt;&gt;n,把a按照bit整体向右边移动n位(在左边补n个0)移位之后,低位舍弃.<br>  <em><strong>对应有符号数,高位补符号位.对于无符号数,高位补0</strong></em></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>搜索算法2</title>
    <url>/2021/07/09/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<h2 id="一、有关图的深度优先搜索和广度优先搜索"><a href="#一、有关图的深度优先搜索和广度优先搜索" class="headerlink" title="一、有关图的深度优先搜索和广度优先搜索"></a>一、有关图的深度优先搜索和广度优先搜索</h2><span id="more"></span>

<h3 id="1、图的表达方式以及图的建立"><a href="#1、图的表达方式以及图的建立" class="headerlink" title="1、图的表达方式以及图的建立"></a>1、图的表达方式以及图的建立</h3><p>邻接矩阵的表示方法：设置顶点数组和邻接矩阵二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN      100   <span class="comment">//图中顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERY_BIG  65535    <span class="comment">//无穷大</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VType V[MAXN] ; <span class="comment">//一维数组用来存储顶点的数据</span></span><br><span class="line"></span><br><span class="line">    WType A[MAXN][MAXN] ; <span class="comment">//存储边上的权w,&quot;邻接矩阵&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> VexNum;<span class="comment">//图中实际顶点的个数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​                                                                            <img src="https://pic.imgdb.cn/item/60e803285132923bf8386a12.png"></p>
<p>例如：数字表示边的权值横向表示起始点方向，没有边的情况表示无穷大，在代码中，无穷大为65535</p>
<p>图的建立过程：先输入顶点集例如：ABCDEFG   然后输入边格式:AB8 (起点 终点 权值) ,当起点输入为’#’ 时退出循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g-&gt;V); <span class="comment">//输入顶点集</span></span><br><span class="line">getchar();     <span class="comment">//清空输入缓冲区</span></span><br><span class="line">g-&gt;VexNum = <span class="built_in">strlen</span>(g-&gt;V);   <span class="comment">//获取顶点数组的有效长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>()</span><br><span class="line">&#123;</span><br><span class="line">           <span class="comment">//邻接二维矩阵初始化为无穷大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> Start;</span><br><span class="line">    <span class="keyword">char</span> Stop;</span><br><span class="line">    <span class="keyword">int</span> w;  <span class="comment">//权值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c%c%d&quot;</span>,&amp;Start,&amp;Stop,&amp;w);   <span class="comment">//输入格式</span></span><br><span class="line">    <span class="keyword">int</span> Startindex = getindex(V,g-&gt;VexNum,Start);  <span class="comment">//输入的字符返回下标</span></span><br><span class="line">    <span class="keyword">int</span> Stopindex = getindex(V,g-&gt;VexNum,STop);    <span class="comment">//输入的字符返回下标</span></span><br><span class="line">    g-&gt;A[Startindex][Stopindex] = w;   <span class="comment">//赋值二维数组以权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、图的深度优先遍历"><a href="#2、图的深度优先遍历" class="headerlink" title="2、图的深度优先遍历"></a>2、图的深度优先遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找第v0 行从pos开始的 有效 结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNextLJD</span><span class="params">(Graph*g , <span class="keyword">int</span> v0, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = pos; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;A[v0][i] != VERY_BIG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//从图中下标为v0的那个顶点出发，按照DFS(深度优先)的去访问它能够访问的</span></span><br><span class="line"><span class="comment">//所有邻接点。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph* g,  <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//(1)访问v0,并标记</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&quot;</span>, g-&gt;V[v0]);</span><br><span class="line">    visited[v0] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">int</span> vi; <span class="comment">//表示 v0的下一个邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (vi = FindNextLJD(g,v0,<span class="number">0</span>); vi != <span class="number">-1</span> ;   vi = FindNextLJD(g,v0, vi+<span class="number">1</span>))  </span><br><span class="line">    <span class="comment">//第一次循环的时候从0开始，下一次从vi的下一个开始查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[vi] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(g, vi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了适配非连通的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraver</span><span class="params">(Graph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先初始化的辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(g, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、图的广度优先遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph* g,  <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Queue[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Queue[rear++] = v0;  <span class="comment">//第一个结点入队</span></span><br><span class="line">    <span class="keyword">if</span>(rear == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rear != front)  <span class="comment">//如果队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vi;</span><br><span class="line">        visited2[Queue[front]] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下一个邻接点入队</span></span><br><span class="line">        <span class="keyword">for</span> (vi = FindNextLJD(g,Queue[front],<span class="number">0</span>); vi != <span class="number">-1</span> ; vi = FindNextLJD(g,Queue[front], vi+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited2[vi] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[rear++] = vi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,g-&gt;V[Queue[front++]]);  <span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rear == <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Yu</title>
    <url>/2021/07/08/Yu/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1、c语言数据类型"><a href="#1、c语言数据类型" class="headerlink" title="1、c语言数据类型"></a><em><strong>1、c语言数据类型</strong></em></h2><span id="more"></span>

<ol>
<li><p>数据类型 </p>
<ul>
<li><p>整形  </p>
<blockquote>
<p>(signed) char/ unsigned char  —&gt;<strong>字符型</strong><br>char 占 1byte(字节) = 8 bits  </p>
</blockquote>
<blockquote>
<p>(signed) short/ unsigned short  —&gt;<strong>短整型</strong><br>short 占 2byte(字节) = 16 bits</p>
</blockquote>
<blockquote>
<p>(signed) int/ unsigned int  —&gt;<strong>整型</strong><br>int 占 4byte(字节) = 32 bits</p>
</blockquote>
<blockquote>
<p>(signed) long/ unsigned long  —&gt;<strong>长整型</strong><br>在32位机器值 long 占 4byte(字节) = 32 bits<br>在64位机器值 long 占 8byte(字节) = 64 bits</p>
</blockquote>
</li>
<li><p>浮点型  </p>
<blockquote>
<p>单精度 float 4byte<br>双精度 double 8byte<br>长精度 long double 12byte  </p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="2、常量与变量"><a href="#2、常量与变量" class="headerlink" title="2、常量与变量"></a><em><strong>2、常量与变量</strong></em></h2><h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a><em><strong>2.1 常量</strong></em></h3><ul>
<li><p>整型常量  </p>
<pre><code>二进制(8421)     
    八进制(以0开头的都是八进制) 136   ----&gt; 001 011 110  
    16进制(以0x/0X开头的)  
    10进制(没有特殊说明都是10进制)
</code></pre>
</li>
<li><p>浮点型常量</p>
<pre><code>带小数的  
    1.2  
    1.2e-3 ----&gt;0.0012  
</code></pre>
</li>
<li><p>字符型常量  </p>
<pre><code>保存的不是形状,是ASCII码.  
    字符&lt;------&gt;整数
</code></pre>
</li>
<li><p>枚举常量</p>
</li>
</ul>
<h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a><em><strong>2.2 变量</strong></em></h3><p><strong>2.2.1.变量的定义</strong>  </p>
<blockquote>
<p>变量类型 变量名;<br>变量的属性(占用多大的空间,取值范围—-&gt;类型)    </p>
</blockquote>
<p><strong>2.2.2.signed/unsigned</strong> </p>
<blockquote>
<p>signed:最高位是符号位,其他都是数值位<br>unsigned:都是数值位  </p>
</blockquote>
<p><strong>2.2.3.变量的保存</strong>      </p>
<blockquote>
<p>存储的是二进制补码<br>原码&lt;—–&gt;补码<br>正数:原码本身<br>负数:原码的绝对值,取反+1(二进制)  </p>
</blockquote>
<h2 id="3、整形数据的存储"><a href="#3、整形数据的存储" class="headerlink" title="3、整形数据的存储"></a><em><strong>3、整形数据的存储</strong></em></h2><ul>
<li><em><strong>3.1 整形数据的存储方法</strong></em></li>
</ul>
<ol>
<li>整形的存储方法<ul>
<li>正数<br>正数的补码就是本身的二进制 <strong>补码=原码</strong></li>
<li>负数<br><strong>原码变补码</strong><br><strong>符号位不变，数据位取反</strong>  原码的绝对值 取反 加一 比如：<br>-13<br>绝对值：13 0000 1101<br>取反：1111 0011<br>加一：1111 0100<br>在计算机中存储的就是 1111 0100<br><strong>补码变原码</strong><br>short a = 32767;<br>short b = a+2;<br>printf(“%d\n”,b);<br>0111 1111 1111 1111 + 0000 0000 0000 0010 = 1000 0000 0000 0001 存储码<br>补码转原码：<strong>符号位不变，数据位取反</strong><br>补码减一 取反 1111 1111 1111 1111 = -32767<br><font color=red size=3><strong>总结：在进行运算的时候，都是补码在进行运算，正数的补码等于原码，故不必再进行转码；当补码为负数或数据溢出时，需将补码转化为原码。</strong></font></li>
</ul>
</li>
</ol>
<ul>
<li><p><em><strong>3.2 signed/unsigned</strong></em></p>
</li>
<li><p><em><strong>3.3 关于整型数据的赋值问题,C语言的标准建议</strong></em>    </p>
<h3 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h3><ul>
<li><p><font color = red size =3><strong>长的赋值给短的（不管有没有符号）</strong> </font></p>
<blockquote>
<p>低字节直接拷贝，高字节直接丢弃</p>
</blockquote>
</li>
</ul>
<h3 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h3><ul>
<li><p><font color = red size=3><strong>短的赋值给长的</strong> </font> </p>
<blockquote>
<p>有符号（signed）那么低字节直接拷贝,高字节全部补符号位<br>无符号（unsigned）那么低字节直接拷贝,高字节全部补0       </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;font color=red size=3&gt;**特例:** **当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型**&lt;/font&gt;
</code></pre>
<ul>
<li><em><strong>3.4 溢出问题</strong></em>  <pre><code>溢出其实就是一个计算值
长----&gt;短
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Yu</tag>
      </tags>
  </entry>
  <entry>
    <title>假期4</title>
    <url>/2021/07/07/%E5%81%87%E6%9C%9F(4)/</url>
    <content><![CDATA[<h2 id="这孩子打小就聪明"><a href="#这孩子打小就聪明" class="headerlink" title="这孩子打小就聪明"></a>这孩子打小就聪明</h2><span id="more"></span>

<p>关于二叉树的递归问题</p>
<h3 id="1、求出二叉树的高度"><a href="#1、求出二叉树的高度" class="headerlink" title="1、求出二叉树的高度"></a>1、求出二叉树的高度</h3><p>递归思路：设置一个宏，比较两个数的最大值   返回左子树函数调用和右子树函数调用加1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b) ?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX(level(t-&gt;lchild),level(t-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、求出数的最大结点"><a href="#2、求出数的最大结点" class="headerlink" title="2、求出数的最大结点"></a>2、求出数的最大结点</h3><p>递归思路:如果右子树存在，返回右子树的函数调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Bitree *<span class="title">max</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、删除整个二叉树"><a href="#3、删除整个二叉树" class="headerlink" title="3、删除整个二叉树"></a>3、删除整个二叉树</h3><p>递归思路：删除左子树，删除右子树，删除本身结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、判断一棵二叉树是否为排序二叉树"><a href="#4、判断一棵二叉树是否为排序二叉树" class="headerlink" title="4、判断一棵二叉树是否为排序二叉树"></a>4、判断一棵二叉树是否为排序二叉树</h3><p>思路:1、中序遍历二叉树，如果得出的数组为升序序列，为二叉排序树</p>
<p>2、左子树是排序树 &amp;&amp; 右子树是排序树 &amp;&amp; 左子树最大值&lt;根&lt;右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、递归构造一棵二叉树"><a href="#5、递归构造一棵二叉树" class="headerlink" title="5、递归构造一棵二叉树"></a>5、递归构造一棵二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序创造二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = c;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);  <span class="comment">//递归方法创建左子树</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);  <span class="comment">//递归方法创建右子树  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法: 为空的地方要用 &quot;0&quot; 填充</span></span><br></pre></td></tr></table></figure>

<h3 id="6、平衡二叉树-AVL-树"><a href="#6、平衡二叉树-AVL-树" class="headerlink" title="6、平衡二叉树(AVL)树"></a>6、平衡二叉树(AVL)树</h3><p>分四种情况：  //为了弄到平衡因子的情况，结点结构体需要加入高度的成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单向右旋   (往左子树加入时，插入结点小于左子树结点)  本身右旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">SingleRotateWithRight</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向左旋   (往右子树加入时，插入结点大于右子树结点) 本身左旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">SingleRotateWithLeft</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结点x进行一个“双向旋转(先左后右)平衡处理”  (往左子树加入时，加入的结点大于左子树结点值) 左子树左旋，本身右旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">DoubleRotateLeftRight</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结点x进行一个“双向旋(先右后左)平衡处理”    (往右子树加入时，加入的结点小于右子树结点值) 右子树右旋，本身左旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">DoubleRotateRightLeft</span><span class="params">(BiTNode *x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所有的左旋右旋操作都在插入时进行操作流程。</p>
<p>递归插入 - &gt;  递归设置高度值 -&gt; 根据平衡因子来判断左右旋的操作</p>
<p>tips:左右旋时要实时更新高度数值,先更新原来根节点的高度数值，然后更新新的根节点的高度数值</p>
<h3 id="7、最短路径"><a href="#7、最短路径" class="headerlink" title="7、最短路径"></a>7、最短路径</h3><p>三个辅助数组</p>
<ol>
<li><p>数组s[n]  标记数组。  s[i] =1  源点v到vi的最短距离是否求出   s[0]  表示没有求出</p>
</li>
<li><p>Dist[n]   最短距离</p>
</li>
<li><p>向量Path[n]  保存最短路径</p>
<p>两个步骤：找到最小值   -&gt; 更新  -&gt;找到最小值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(--n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> Min = VERY_BIG;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Vexnum;i++)     <span class="comment">//找到最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="number">0</span> &amp;&amp; Dist[i]&lt;Min)</span><br><span class="line">        &#123;</span><br><span class="line">            Min = Dist[i];</span><br><span class="line">            w = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Dist[w] + g-&gt;A[w][i] &lt; Dist[i])</span><br><span class="line">        &#123;</span><br><span class="line">            Dist[i] = Dist[w] + g-&gt;A[w][i];</span><br><span class="line">            <span class="built_in">strcpy</span>(Path[i],Path[w]);</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">strlen</span>(Path[w]);</span><br><span class="line">            Path[i][l] = g-&gt;V[i];</span><br><span class="line">            Path[i][l+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(3)</title>
    <url>/2021/07/05/%E5%81%87%E6%9C%9F(3)/</url>
    <content><![CDATA[<h1 id="Third-03-树"><a href="#Third-03-树" class="headerlink" title="Third 03  树"></a>Third 03  树</h1><p>10.40</p>
<span id="more"></span>

<p>详细教程:<a href="https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a></p>
<h2 id="1、树和二叉树的基本概念"><a href="#1、树和二叉树的基本概念" class="headerlink" title="1、树和二叉树的基本概念"></a>1、树和二叉树的基本概念</h2><p>度为零的结点称之为叶子结点，度不为零的称之为非终端结点。最大层次为树的高度或深度</p>
<h2 id="2、二叉树-Binary-Tree"><a href="#2、二叉树-Binary-Tree" class="headerlink" title="2、二叉树(Binary Tree)"></a>2、二叉树(Binary Tree)</h2><p>每个结点最多只有两棵子树(不存在 度大于2 的结点) </p>
<p>满二叉树:在不增加树的高度下，没法在树中添加结点</p>
<p>完全二叉树:  (1) 除去最后一层，这棵树是满二叉树 (2)最后一层靠左边</p>
<p>二叉树性质:    </p>
<p>遍历方法：前序遍历，中序遍历，后序遍历都可以用递归来实现  层序遍历需要用到队列的方法</p>
<h3 id="1、tip-层序遍历-二叉树的层序遍历运用到队列操作"><a href="#1、tip-层序遍历-二叉树的层序遍历运用到队列操作" class="headerlink" title="1、tip:层序遍历:  二叉树的层序遍历运用到队列操作"></a>1、tip:层序遍历:  二叉树的层序遍历运用到队列操作</h3><ul>
<li><p>首先，根结点 1 入队；</p>
</li>
<li><p>根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；</p>
</li>
<li><p>队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；</p>
</li>
<li><p>队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；</p>
</li>
<li><p>不断地循环，直至队列内为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//根节点入队 Queue, 队列存储的类型应该是结点类型的</span></span><br><span class="line">Enqueue(q,p); </span><br><span class="line"><span class="keyword">while</span>(队列不为空)   <span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    p = Dequeue(q,p);  <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代方式实现遍历"><a href="#2、迭代方式实现遍历" class="headerlink" title="2、迭代方式实现遍历"></a>2、迭代方式实现遍历</h3><p>详细教程:</p>
<p><a href="https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen</a></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>1、首先创建一个栈，初始情况下，把根节点入栈</p>
</li>
</ul>
<p>​       2、进入循环<br>​       a）取栈顶元素（出栈）<br>​       b）访问该元素<br>​       c）如果该元素的右子树不为空，就入栈；如果左子树不为空也入栈，当栈为空时，遍历完成。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>​        1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​        2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​        3、当cur为空，（此时栈顶元素是目前的最左侧元素），出栈并访问<br>​        4、让cur指向刚刚被访问的节点的右子树，循环2、3、4步骤</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>​       1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​       2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​       3、当cur为空，取栈顶元素（如果栈顶元素被访问即被打印才可出栈，否则依然在栈里面），判断是否能够访问：<br>​       a）可以访问：<br>​       如果栈顶元素右子树为null，则可以访问<br>​       栈顶元素已经被访问过了，则可以访问，定义一个prev变量记录上一个被访问过的元素<br>​       b）不能访问：<br>​       让cur从栈顶元素的右子树出发继续进行1、2、3步骤</p>
<h2 id="3、二叉排序树的删除"><a href="#3、二叉排序树的删除" class="headerlink" title="3、二叉排序树的删除"></a>3、二叉排序树的删除</h2><p>步骤：先找到待删除的结点，然后据情况判断</p>
<p>1、如果结点没有孩子，直接删除</p>
<p>2、如果只有一个孩子，父结点直接指向孩子结点，删除该结点</p>
<p>3、如果 px 两个孩子都有，找到左子树的最大值作为”替罪羊” ，它的值赋给px，然后跳到开头处理px 的操作进行删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">DeleteX</span><span class="params">(BiTNode *t, TElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BiTNode *px = t; <span class="comment">//指向要删除的结点</span></span><br><span class="line">    BiTNode *pf; <span class="comment">//指向px的父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先找到要删除的结点</span></span><br><span class="line">    <span class="keyword">while</span> (px)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">delete_op:</span><br><span class="line">    <span class="comment">//! 找到了，分情况删除</span></span><br><span class="line">    <span class="keyword">if</span> (px-&gt;lchild == <span class="literal">NULL</span> &amp;&amp;  px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (px == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == pf-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//! px只有右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px只有左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">           pf-&gt;lchild = px-&gt;lchild;</span><br><span class="line">           px-&gt;lchild =<span class="literal">NULL</span>;</span><br><span class="line">           <span class="built_in">free</span>(px);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px左右孩子俱全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要找一个“替罪 yang”</span></span><br><span class="line">        <span class="comment">// 找左边最大值结点:左拐-&gt;右拐-&gt;右拐 ...</span></span><br><span class="line"></span><br><span class="line">        BiTNode *r = px;</span><br><span class="line"></span><br><span class="line">        pf  = px;</span><br><span class="line">        px = px-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (px-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r-&gt;data = px-&gt;data; <span class="comment">//!  </span></span><br><span class="line">        <span class="keyword">goto</span> delete_op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、树，二叉树。森林的转换"><a href="#4、树，二叉树。森林的转换" class="headerlink" title="4、树，二叉树。森林的转换"></a>4、树，二叉树。森林的转换</h2><p>树 &lt;-&gt; 二叉树 :   </p>
<ol>
<li><img src="https://pic.imgdb.cn/item/60e43c5c5132923bf8ce7b96.jpg"></li>
</ol>
<p>（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</p>
<p>2、森林转换成二叉树</p>
<ol>
<li>把每棵树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
<li><img src="https://pic.imgdb.cn/item/60e43e475132923bf8d67d22.jpg"></li>
</ol>
]]></content>
      <categories>
        <category>假期</category>
      </categories>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(2)</title>
    <url>/2021/07/02/%E5%81%87%E6%9C%9F(2)/</url>
    <content><![CDATA[<h2 id="Second-–-02（栈）"><a href="#Second-–-02（栈）" class="headerlink" title="Second – 02（栈）"></a>Second – 02（栈）</h2><p>9.24  AM</p>
<span id="more"></span>

<h2 id="一、小题"><a href="#一、小题" class="headerlink" title="一、小题"></a>一、小题</h2><h3 id="（1）删除结点问题"><a href="#（1）删除结点问题" class="headerlink" title="（1）删除结点问题"></a>（1）删除结点问题</h3><p><img src="https://pic.imgdb.cn/item/60de6b3e5132923bf85b2a6e.png"></p>
<h3 id="2-单链表：写一个函数合并两个升序单链表"><a href="#2-单链表：写一个函数合并两个升序单链表" class="headerlink" title="(2)单链表：写一个函数合并两个升序单链表"></a>(2)单链表：写一个函数合并两个升序单链表</h3><p>要求：不能额外申请空间，合并的链表仍然有序</p>
<p>两种方法:  一种直接一个一个插入</p>
<p>二种:两两pk，谁小往后面挪 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Merge</span><span class="params">(Node* ha, Node* hb)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法一:</span></span><br><span class="line"><span class="comment">      把ha的结点一个一个摘下来，然后按“插入排序”</span></span><br><span class="line"><span class="comment">      插入到hb的链表中去。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法二:</span></span><br><span class="line"><span class="comment">      “两两PK,谁小谁往后挪，挪之前先链接起来”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      ph 指向合并后的链表的第一个结点</span></span><br><span class="line"><span class="comment">      pt 指向合并后的链表的最后一个结点*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = ha;</span><br><span class="line">          ha = ha-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = hb;</span><br><span class="line">          hb = hb-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (ha &amp;&amp; hb)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = ha;</span><br><span class="line">              pt = ha;</span><br><span class="line">              ha = ha-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = hb;</span><br><span class="line">              pt = hb;</span><br><span class="line">              hb = hb-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ha)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = ha;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hb)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = hb;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ph;</span><br></pre></td></tr></table></figure>

<h3 id="3-对一个单链表进行排序"><a href="#3-对一个单链表进行排序" class="headerlink" title="(3)对一个单链表进行排序"></a>(3)对一个单链表进行排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node*  <span class="title">Sort_Bubble</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span> || h-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *pk = h;  </span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向pk前面的那个结点 </span></span><br><span class="line">    Node *pn = (pk == <span class="literal">NULL</span>) ? <span class="literal">NULL</span>: pk-&gt;next; </span><br><span class="line">        <span class="comment">//pn指向pk后面的那个结点</span></span><br><span class="line"></span><br><span class="line">    Node *ps = <span class="literal">NULL</span>;<span class="comment">//指向后面的那个有序表的第一个结点</span></span><br><span class="line">    Node *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h != ps)  <span class="comment">//已排序后的部分逼到头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pk = h;</span><br><span class="line">        pn = pk-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pn != ps)  <span class="comment">//pn后面跟着的是已排好的部分</span></span><br><span class="line">        &#123;</span><br><span class="line">		   <span class="keyword">if</span> (pk-&gt;data &lt;= pn-&gt;data)  <span class="comment">//如果有序的话，直接移位</span></span><br><span class="line">            &#123;</span><br><span class="line">                pr = pk;</span><br><span class="line">                pk = pn;</span><br><span class="line">                pn = pn-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>   <span class="comment">//开始交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = pn-&gt;next;</span><br><span class="line">                pn-&gt;next = pk;</span><br><span class="line">                pk-&gt;next = r;</span><br><span class="line">                <span class="keyword">if</span> (pr)</span><br><span class="line">                &#123;</span><br><span class="line">                    pr-&gt;next = pn;</span><br><span class="line">                &#125;</span><br><span class="line">                pr = pn;</span><br><span class="line">                pn = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ps = pk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><p><img src="https://pic.imgdb.cn/item/60debb855132923bf8261c96.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfc8735132923bf8964303.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfcb965132923bf8ac9a02.png"></p>
<p>​                                                            //  fgets函数的应用  ，其不能识别换行符(回车键),所以进行代替操作   </p>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>栈顶和栈底倒转，头部删除（不需要引入另一个指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="comment">//&quot;数据结点&quot;存放栈元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SELemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;SNode;</span><br><span class="line"></span><br><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SNode *Bottom; <span class="comment">//指向栈底元素</span></span><br><span class="line">    SNode *Top;  <span class="comment">//指向栈顶的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//链式栈的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>链式栈的清空和销毁：清空表示干掉所有数据结点</p>
<p>销毁表示还要干掉头结点</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队尾(rear):允许插入元素的一端</p>
<p>队头(front):允许删除元素的一端</p>
<p>实现：顺序结构和链式结构，操作：InitQueue  DestroyQueue ClearQueue   QueueIsEmpty  QueueLength</p>
<p>“排队论”</p>
<h3 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="(1)顺序队列"></a>(1)顺序队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现理念：数组，队尾，队首指针，数组的最大长度。</span></span><br><span class="line"><span class="comment">  入队从队尾入，出队从队首出。队尾队首的表示方法都是下标表示</span></span><br><span class="line"><span class="comment">  能够实现空间循环使用的效果：出队或者入队。如果队尾/队首指针达到最大长度时，自动转到下标为零(数组空间开头)</span></span><br><span class="line"><span class="comment">  实现空间的循环利用。实现队列存储操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）链式队列"><a href="#（2）链式队列" class="headerlink" title="（2）链式队列"></a>（2）链式队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据结点类型描述：数据域，前指针和后指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存队元素的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NOde</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *Front; <span class="comment">//指向队头结点</span></span><br><span class="line">    Node *Rear;  <span class="comment">//指向队尾结点</span></span><br><span class="line">    <span class="keyword">int</span> Length;  <span class="comment">//队列中元素的个数</span></span><br><span class="line">&#125;LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列类型头指针:队首元素的指针 队尾元素的指针 队列元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）不采用长度标志位-availuble-标志长度"><a href="#（3）不采用长度标志位-availuble-标志长度" class="headerlink" title="（3）不采用长度标志位   availuble 标志长度"></a>（3）不采用长度标志位   availuble 标志长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//牺牲一个空间，rear 指向最后一个空位表示满</span></span><br><span class="line">(rear + <span class="number">1</span>) % capacity == front  <span class="comment">//队列满</span></span><br><span class="line">front == rear    <span class="comment">//队列为空</span></span><br><span class="line">(rear-front+capacity)%capacity   <span class="comment">//计算元素个数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2021/07/01/Leetcode/</url>
    <content><![CDATA[<h2 id="复习-day01"><a href="#复习-day01" class="headerlink" title="复习(day01)"></a>复习(day01)</h2><span id="more"></span>

<h2 id="1、双指针"><a href="#1、双指针" class="headerlink" title="1、双指针"></a>1、双指针</h2><h3 id="（1）、合并两个有序数组"><a href="#（1）、合并两个有序数组" class="headerlink" title="（1）、合并两个有序数组"></a>（1）、合并两个有序数组</h3><p><img src="https://pic.imgdb.cn/item/60dda26d5132923bf8e4a2ad.png"></p>
<blockquote>
<p>将num1 扩容到两个数组合并大小三个指针，一个指向待操作的位置，一个指向num1,一个指向num2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> m,vector&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = m-- +n-- <span class="number">-1</span>; <span class="comment">//指向操作的位置</span></span><br><span class="line">    <span class="keyword">while</span>(m &gt;= <span class="number">0</span> &amp;&amp; n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums1[m] &gt; nums[n] ? nums1[m--]:nums2[n--]; <span class="comment">//两边开始走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--]; <span class="comment">//n1走完表示直接添加 n2要继续走完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）快慢指针（判断链表是否有环"><a href="#（2）快慢指针（判断链表是否有环" class="headerlink" title="（2）快慢指针（判断链表是否有环)"></a>（2）快慢指针（判断链表是否有环)</h3><p>判断链表是否有环，可以采用快慢指针，判断入环的位置，需要将快指针调到头结点，然后两个结点再走，碰到一起说明环的初始位置</p>
<h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="(3)滑动窗口"></a>(3)滑动窗口</h3><p>给定两个字符串 S 和 T，求 S 中包含 T 所有字符的最短连续子字符串的长度，同时要求时间 复杂度不得超过 O(n)。</p>
<p><img src="https://pic.imgdb.cn/item/60dda6535132923bf8f5a171.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;       <span class="comment">//记录T中的字符情况个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;  <span class="comment">//记录T中的字符情况</span></span><br><span class="line">    <span class="comment">// 先统计T中的字符情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        flag[T[i]] = <span class="literal">true</span>;  <span class="comment">//对应字符情况</span></span><br><span class="line">        ++chars[T[i]];    <span class="comment">//对应字符的个数分布</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动滑动窗口，不断更改统计数据</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若目前滑动窗口已包含T中全部字符，</span></span><br><span class="line">            <span class="comment">// 则尝试将l右移，在不影响结果的情况下获得最短子字符串</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="comment">//如果l缩小时，遇到待选字符，退还一个剩余量，并且cnt--,同时l++,r开始向右移动</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size &gt; S.<span class="built_in">size</span>()? <span class="string">&quot;&quot;</span>: S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><h3 id="（1）求开方"><a href="#（1）求开方" class="headerlink" title="（1）求开方"></a>（1）求开方</h3><p>设置一个非负整数，求它的开方，向下取整</p>
<p>例如： 8  -&gt;  2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>假期</title>
    <url>/2021/06/19/%E5%81%87%E6%9C%9F(1)/</url>
    <content><![CDATA[<h2 id="First-–-01-链表操作"><a href="#First-–-01-链表操作" class="headerlink" title="First – 01    (链表操作)"></a>First – 01    (链表操作)</h2><span id="more"></span>

<h3 id="1、vscode-连接ubuntu-连接虚拟机上的Ubuntu"><a href="#1、vscode-连接ubuntu-连接虚拟机上的Ubuntu" class="headerlink" title="1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :"></a>1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :</h3><ul>
<li><p><input checked="" disabled="" type="checkbox">  1、ubuntu 安装ssh :  sudo apt-get install ssh</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  2、 vscode 终端命令 :  ssh  (用户名)@ IP     //连接  （vscode安装ssh   client  插件）</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60dbd5795132923bf8015adc.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 3、虚拟机上网：网络桥接模式</li>
</ul>
<h3 id="2、递归版本的有序链表插入"><a href="#2、递归版本的有序链表插入" class="headerlink" title="2、递归版本的有序链表插入"></a>2、递归版本的有序链表插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Insert</span><span class="params">(Node *h,Node *p)</span>  <span class="comment">//递归方式插入有序链表  返回头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;= h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &gt; h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Insert(h-&gt;next,p); <span class="comment">//递归  最后吐出来的是头结点后面的位置</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、非递归的插入方法"><a href="#3、非递归的插入方法" class="headerlink" title="3、非递归的插入方法"></a>3、非递归的插入方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到插入位置</span></span><br><span class="line"><span class="comment">//分情况讨论  找到和没找到</span></span><br><span class="line"></span><br><span class="line">Node *pk = h;  <span class="comment">//pk指向</span></span><br><span class="line">Node *pr = <span class="literal">NULL</span>;  <span class="comment">//pr指向pk的前驱点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pk-&gt;data &gt;= p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pr = pk;</span><br><span class="line">    pk = pk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pk == <span class="literal">NULL</span>)   <span class="comment">//最后一个</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    pr-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pk == h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        h = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中间插入</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        pr-&gt;next =p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为x的结点</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除算法:</span></span><br><span class="line">    <span class="comment">//1. 找到要删除的结点</span></span><br><span class="line">    <span class="comment">// 遍历链表找到值为x的结点(要删除的结点)px及它前驱结点pr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 分情况删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//px指向要删除的结点</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>; <span class="comment">//pr指向px的前驱结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//px每次搜索开始的那个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        px = ps;</span><br><span class="line">        <span class="keyword">while</span> (px)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps = px-&gt;next; <span class="comment">//下一次搜索的起点就是要删除的结点的下一个!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == h)</span><br><span class="line">        &#123;</span><br><span class="line">            h = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;next = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X_v2</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        Node *px = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Delete_X_v2(h,x);  <span class="comment">//如果后面还有待删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Delete_X_v2(h-&gt;next, x);   <span class="comment">//递归删除中间的结点</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h3><p>正负数排序</p>
<p>相对位置不变，时间复杂度O(n),不能申请新的空间</p>
<p>算法1：依次摘除负数结点，链接剩下的。成功排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Adjust</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *first = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的第一个结点</span></span><br><span class="line">    Node *last = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的最后一个结点</span></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//指向原链表中“下一个要摘除的结点”</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向px前面的那个结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//下一次搜索的起始结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//&quot;查找下一个负数结点&quot;</span></span><br><span class="line">        px = ps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (px)   <span class="comment">//第一次找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//“查找的结果只有两种情况：要么没有找到，要么找到了”</span></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)  <span class="comment">//遍历完成，没有找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原链表上已经不存在“负数结点”啦</span></span><br><span class="line">            <span class="comment">//这个时候，你需要做的事情是：把负数链表和剩余的</span></span><br><span class="line">            <span class="comment">// 原链表链起来就可以了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last-&gt;next = h;</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ps = px-&gt;next; <span class="comment">//下一次搜索的起始结点。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//“找到下一个负数结点啦”</span></span><br><span class="line">            <span class="comment">//(1)先把该负数结点从原链表中摘除下来</span></span><br><span class="line">            <span class="keyword">if</span> (px == h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点是原链表中的“第一个结点”</span></span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点不是原链表中的第一个结点</span></span><br><span class="line">                pr-&gt;next = px-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)把该负数结点按“尾插法”加入到新负数链表中去</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                first = px;</span><br><span class="line">                last = px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; </span><br><span class="line">                last-&gt;next = px;</span><br><span class="line">                last = px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、逆转链表</p>
<ol start="2">
<li> 就地逆置一个单链表<br> 例子:<pre><code> h:  1 5 3 4 
 =&gt;
 h: 4 3 5 1 
</code></pre>
 要求：<pre><code> 不能新申请结点的空间
</code></pre>
</li>
</ol>
<p>​    算法一:<br>​        1. 把原链表上的结点一一(从第一个到最后一个)摘除下来<br>​                2. 把摘除下来的结点，按“头插法”加入到新链表中</p>
<p>​        p 指向新摘除的结点<br>​        </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first =<span class="literal">NULL</span>; <span class="comment">//指向新链表的第一个结点</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (h)</span><br><span class="line">​        &#123;</span><br><span class="line">​            p = h;</span><br><span class="line">​            h = h-&gt;next;</span><br><span class="line">​            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">​            &#123;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line">​            <span class="keyword">else</span></span><br><span class="line">​            &#123;</span><br><span class="line">​                p-&gt;next = first;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure>

<p>​    算法二:<br>​        把原链表“一分为二”：<br>​            第一个结点为链表1， h1指向第一个链表的第一个结点<br>​            其余结点为链表2    h2指向后面那个链表的第一个结点</p>
<p>​        只考虑h1和h2这两个结点，逆置，h2放置在h1的前面</p>
<p>​            p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​            h2-&gt;next = h1;<br>​            h1 = h2;<br>​            h2 = p;</p>
<p>​            h1 = h;<br>​            h2 = h-&gt;next ;<br>​            h-&gt;next = NULL;</p>
<p>​            while (h2)<br>​            {<br>​                p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​                h2-&gt;next = h1;<br>​                h1 = h2;<br>​                h2 = p;</p>
<p>​            }</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	Node*</span><br><span class="line">​	reverse(Node* h)</span><br><span class="line">​	&#123;</span><br><span class="line">​	         h1 = h;</span><br><span class="line">​            h2 = h-&gt;next ;</span><br><span class="line">​            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">while</span> (h2)</span><br><span class="line">​            &#123;</span><br><span class="line">​                p = h2-&gt;next; <span class="comment">//先保存后面那个链表的第二个结点</span></span><br><span class="line">​                h2-&gt;next = h1;</span><br><span class="line">​                h1 = h2; </span><br><span class="line">​                h2 = p;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line">​	</span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>双链表的打印方式可以用递归的方法实现 先递归打印 p-&gt;next，然后打印本身</p>
</blockquote>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事-实训(智能家居系统)</title>
    <url>/2021/06/16/%E6%97%A5%E5%B8%B8%E4%BA%8B-2/</url>
    <content><![CDATA[<p>为期三周的实训告一段落。</p>
<span id="more"></span>

<h1 id="完成智能家居系统"><a href="#完成智能家居系统" class="headerlink" title="完成智能家居系统"></a>完成智能家居系统</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>学习Zigbee 无线局域网 的组网技术。 </p>
<p>开发工具包：Ztack 协议栈  软件：一个下载软件 ，一个编译软件。 以.hex文件烧录到Zigbee模块。外设有：LED灯，温度，湿度检测，按键。</p>
<p>成品:1.一个模块作为适配器，适配器是局域网组网的原点。2、共有三种模式：适配器模式，路由器模式和终端模式  3、适配器和终端组网通信，通过串口打印信息。</p>
<h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p>学习C++基础知识。新知识点：构造函数的知识，编译器优化和不优化的区别以及指令。《Prime C++》看完，内容多而杂。后期提升多敲代码。对C++颇感兴趣</p>
<h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p>学习QT的知识。</p>
<p>重中之重。。看完B站上的QT教程 <a href="https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14">https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14</a> </p>
<p>如今，着重运用的技术有：信号和槽、各种组件类的运用，QT提供的服务(主要存放在.obj文件上)。-&gt;QT程序在Linux环境上的交叉编译，生成可执行文件。传输到GEC6818开发板上运行程序。</p>
<p>总结:QT的基本概念清晰。但是，软肋就是不会折腾。室友夜以继日的卷，明显自己的基本了解完全不行&gt;__&lt; 。 外加美术功底的问题，界面设计实在不太理想。。</p>
<h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>多多更新博客，多多上传项目到github，多多折腾</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx那些事</title>
    <url>/2021/06/04/nginx%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="Nginx那些事儿"><a href="#Nginx那些事儿" class="headerlink" title="Nginx那些事儿"></a>Nginx那些事儿</h2><p>nginx简介：<strong>高性能的HTTP</strong>和<strong>反向代理Web服务器</strong>，提供各种服务 IMAP/POP3/SMTP 等等服务。</p>
<span id="more"></span>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>(1)正向代理:在客户端需要配置代理服务器，通过代理服务器进行互联网访问</p>
<p>(2)反向代理：客户端不需要配置 反向代理服务器 。 对外，反向代理服务器和目标是一个服务器</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>QT那些事儿(1)</title>
    <url>/2021/05/15/QT%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-1/</url>
    <content><![CDATA[<h2 id="QT那些事儿（1）"><a href="#QT那些事儿（1）" class="headerlink" title="QT那些事儿（1）"></a>QT那些事儿（1）</h2><h3 id="1、QT是神马？"><a href="#1、QT是神马？" class="headerlink" title="1、QT是神马？"></a>1、QT是神马？</h3><span id="more"></span>

<blockquote>
<p><strong>关于QT的介绍呢，让我们乘上时光机</strong> <a href="https://zhuanlan.zhihu.com/p/140489718">https://zhuanlan.zhihu.com/p/140489718</a> <strong>一探究竟</strong></p>
</blockquote>
<p>QT呢，是C++御用图形用户界面应用程序框架，与 <u><strong>嵌入式Liunx</strong></u>，<strong>C++</strong> 的开发密不可分。</p>
<blockquote>
<p><strong>先学C++基础语法，基本数据类型，两个复合类型，几种主要的语句，类最基本的创建，构造，析构，就可以学Qt，在Qt中逐渐学会类的构建，类的特性，继承，多态等等，学Qt的时候慢慢感受类，能让你对类和面向对象有更深入的理解，而且可以模仿Qt框架类的实现，它本身就是C++的一个类群</strong></p>
</blockquote>
<h3 id="2、面向offer的编程"><a href="#2、面向offer的编程" class="headerlink" title="2、面向offer的编程"></a>2、面向offer的编程</h3><p>作为一名合格的程序员呢，应该有自己的一套核心技术栈，采集与某 app 的职位招聘信息</p>
<p>（1）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6f946ae4f77d3520011f.jpg"></p>
<p>（2）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6fcf6ae4f77d352323b8.jpg"></p>
<p>（3）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6ff26ae4f77d352524d9.jpg"></p>
<p><em><strong>高薪offer冲冲冲</strong> ✌</em></p>
]]></content>
      <tags>
        <tag>QT那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事</title>
    <url>/2021/05/11/%E6%97%A5%E5%B8%B8%E4%BA%8B/</url>
    <content><![CDATA[<p>冲浪发现的博客</p>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/609a400dd1a9ae528f35806c.png"></p>
<blockquote>
<p><a href="https://wujun234.github.io/">https://wujun234.github.io/</a></p>
</blockquote>
<p>有时候找些想要学的途径，杂七杂八的不好下手，非常好的知识梳理框架，康康大佬是怎么学习的</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之旅(1)</title>
    <url>/2021/05/09/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-1/</url>
    <content><![CDATA[<h1 id="学习之旅-1"><a href="#学习之旅-1" class="headerlink" title="学习之旅(1)"></a>学习之旅(1)</h1><p>本篇章记录自己的学习生活。至于有多少后序呢，，，，，，</p>
<span id="more"></span>

<p>写博客嘞，找点素材，有时间把博客功能丰富一下。作为一名学习参与者，记录一下近期的学习的晋升之旅</p>
<p><em>现阶段呢，还是以啃书为主。各种书的资源呢，也许我会上传到github</em></p>
<h2 id="1、C-的学习"><a href="#1、C-的学习" class="headerlink" title="1、C++的学习"></a>1、C++的学习</h2><p>先说一下对学习C++的印象哈，语言的学习嘛，多而杂。最近在啃那个《Primer C++》</p>
<p>就这：</p>
<p><img src="https://pic.imgdb.cn/item/6097861cd1a9ae528f259d63.png"></p>
<p>有人会说啊，这个这个语言不就那几个循环啊，条件判断什么的嘛，过一遍就行。这样下去是不行滴昂，比如说，变量声明和定义的区别，作用域的理解啊。。。巴拉巴拉，语言的学习呢，还是要细致一点滴。经过C语言学习的惨痛教训呢(当时没认真听课)，深刻认识到语言的学习要细致入微。这本书呢，还是C++入门级别 &gt;__&lt;，别急，慢慢来，时间多的很。</p>
<blockquote>
<p><a href="https://light-city.club/sc/">https://light-city.club/sc/</a>  ，这个呢，是一个大佬的晋升之路。至于自己能走到哪，看造化吧。  </p>
</blockquote>
<h2 id="2、LeetCode-算法刷题"><a href="#2、LeetCode-算法刷题" class="headerlink" title="2、LeetCode 算法刷题"></a>2、LeetCode 算法刷题</h2><p>比起C++呢，这个篇章没有那么多，那么杂。But,but,真的耗时间。算法嘛，相当于修炼内功了，打好扎实的基础还是很有好处滴</p>
<p><img src="https://pic.imgdb.cn/item/60978afdd1a9ae528f608a6e.png"></p>
<p>这本书呢，是一个Google大佬编的，对我呢还是挺友好的，现在看到了那个分治法。刷题也要先学基本功对不对，进力扣网站，刚开始就整一些动态规划啊，贪心算法巴拉巴拉的名词，一道题刷一天也不是办法对不对。</p>
<h2 id="3、Linux-Unix系统开发的学习"><a href="#3、Linux-Unix系统开发的学习" class="headerlink" title="3、Linux /Unix系统开发的学习"></a>3、Linux /Unix系统开发的学习</h2><p>因为呢，本身是走嵌入式开发学习方向的啊，Linux 的学习必不可少。之前几个学期呢，学了Shell 编程啊，进程开发，通信啊，文件IO什么的。又说呢，学习要细致，来，上干货啃书。</p>
<p><img src="https://pic.imgdb.cn/item/60978d33d1a9ae528f80c0aa.png"></p>
<p>嘶，，822页。但是呢，我之前五一啃完了一本Linux 系统编程。看着目录还行，内容上面都是老熟人了，得空就啃了。</p>
<h2 id="4、数据结构的学习"><a href="#4、数据结构的学习" class="headerlink" title="4、数据结构的学习"></a>4、数据结构的学习</h2><p>3月份呢，过了一遍数据结构的书，但是呢，现在基本忘光。二刷，不就树啊，图什么的。</p>
<h2 id="5、英语"><a href="#5、英语" class="headerlink" title="5、英语"></a>5、英语</h2><p>6月份考六级了，现在呢，单词准备过第二遍，刷十几套试卷什么的，这不，上午刚了<u>七十几个</u>单词 ，不是吹的，主要是第二遍，速度比较抓紧一点。刷试卷还是要刷滴，英语考试对我来说就是考题感，感觉刷上来了什么都好说。</p>
<p>完，暂时就这些，后期呢，准备搞一下网络，单片机，ARM开发的复习，还有搞一下QT的学习。下午的话搞一下这个博客的使用，再看一下科目四，星期二就要拿证了，芜湖~</p>
]]></content>
      <tags>
        <tag>学习之旅</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2021/05/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><span id="more"></span>

<p>在搜索到一个新的节点时，立即对该新节点进行遍历，需要依靠先入后出的栈来实现，也可以通过与栈等价的递归来实现。也可以用来检测环路。拓扑排序可以判断是否有环路。</p>
<h3 id="1、最大水洼求值"><a href="#1、最大水洼求值" class="headerlink" title="1、最大水洼求值"></a>1、最大水洼求值</h3><p>Input: [[1,0,1,1,0,1,0,1], </p>
<p>​           [1,0,1,1,0,1,1,1],</p>
<p>​           [0,0,0,0,0,0,0,1]]                    Output: 6</p>
<h4 id="递归思路："><a href="#递归思路：" class="headerlink" title="递归思路："></a>递归思路：</h4><p>​           (1)  分为主函数( 用于遍历判断” 1 “ 的位置，开始递归搜索 )和辅函数( 用于递归搜索”1”的位置)</p>
<p>​           (2) 辅函数中逢”1” 置 “0” ，临近水洼置”0” , 避免重复判断</p>
<p>​           (3)递归搜索时，边界(矩阵越界)判断方法两种：先判断是否越界再开始搜索（即判断放在调用 递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合 法（即判断放在辅函数第一行）。</p>
<p>第一种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//判断上下左右的位置</span></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;   <span class="comment">//遍历二维数组得到陷入递归函数的调用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;   <span class="comment">//判断水洼陷入递归函数调用</span></span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));  <span class="comment">//比较函数，得到最大数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y, area = <span class="number">1</span>;   <span class="comment">//每一次递归(取到一个&quot;1&quot;)都会return 一个area,最后累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];   <span class="comment">//取四个方向的递归</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);   <span class="comment">//累计水洼数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() ||c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的写法："><a href="#栈的写法：" class="headerlink" title="栈的写法："></a>栈的写法：</h4><p>关于图片加载的问题：上传到github ,下一篇开始采用聚合图床上传</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B0%B4%E6%B4%BC.png" alt="水洼"></p>
<p>思路：针对每一个入栈的元素 [r , c] 都进行4次的坐标入栈。 local_area 的累加都在判断中间。max 的 取值都在主循环</p>
<h3 id="2、海流方向"><a href="#2、海流方向" class="headerlink" title="2、海流方向"></a>2、海流方向</h3><p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B5%B7%E6%B5%81%E6%96%B9%E5%90%91.png"></p>
<p>思路：因此我们可以反过来想，从两个大洋开始向上流，这样我们 只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋 向上流都能到达的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到太平洋</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到大西洋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);    <span class="comment">//左边开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);  <span class="comment">//从右边开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);    <span class="comment">//从上面开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);   <span class="comment">//从下面开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);      <span class="comment">//两大洋都能流到，压栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; can_reach,<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;   <span class="comment">//满足条件(找到最高点即退出循环，可以先置&quot;true&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>()</span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            matrix[r][c] &lt;= matrix[x][y]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);  <span class="comment">//判断条件为：边界判断以及最高点条件判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><blockquote>
<p>[修改当前节点状态]→[递归子节点]→[回改当前节点 状态]。         此路不通，修改之前一步的状态，回退一步，继续搜索。</p>
</blockquote>
<h3 id="1、全排列"><a href="#1、全排列" class="headerlink" title="1、全排列"></a>1、全排列</h3><p>[1,2,3]  的可能排列方式 ，题解可以采用树形结构：</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E5%85%A8%E6%8E%92%E5%88%97.png" alt="全排列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>1、level 为树的层次，递归的终止条件为：level == nums.size() -1,到树底部终结递归</p>
<p>2、for循环中的 level 和 level+1 ，每次递归都会随着树的深度增加而发生变化，但是始终没有改变值。(栈空间的临时存储)。</p>
<p>3、过程模拟:  第一棵树： i = 0,level=0 , 即[1,2,3],进行交换。子树里面,level增加，i又要从level到nums.size()-1来分配情况。第一个确定，依据 level 来交换情况</p>
<p>4、i+1 的时候要回退一步(回到根节点来进行回溯)。在修改结点，递归后面回退根节点的状态，即swap(nums[i],nums[level]);</p>
<h3 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h3><p>Input: n = 4, k = 2 </p>
<p>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;  <span class="comment">//最后输出数据</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);  <span class="comment">//count 计算深度,comb临时两个[a,b]数组，&quot;1&quot;为初始位置开始也可看做深度</span></span><br><span class="line">    <span class="comment">//count作为数组的编号取值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; comb, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  pos, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; ++i) &#123;</span><br><span class="line">        comb[count++] = i; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k); <span class="comment">// 递归子节点</span></span><br><span class="line">        --count; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E7%BB%84%E5%90%88.png"></p>
<h3 id="3、字符串搜索"><a href="#3、字符串搜索" class="headerlink" title="3、字符串搜索"></a>3、字符串搜索</h3><p>Input: word = “ABCCED”, board = [[’A’,’B’,’C’,’E’],</p>
<p>​                                                        [’S’,’F’,’C’,’S’], </p>
<p>​                                                        [’A’,’D’,’E’,’E’]] </p>
<p>Output: true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="keyword">bool</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  &amp; find, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">    <span class="comment">// 递归子节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>广度优先搜索(BFS)采用先进先出的队列结构，深度优先采用先进后出的栈结构</p>
<h3 id="1、两个岛屿最小距离"><a href="#1、两个岛屿最小距离" class="headerlink" title="1、两个岛屿最小距离"></a>1、两个岛屿最小距离</h3><p>(深度优先查找一个岛屿的位置，全部置为”2” , 接着从岛屿的各个周围遍历，直到找到另一个岛屿，即是最短距离)</p>
<p>Input: </p>
<p>​          [[1,1,1,1,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,0,1,0,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,1,1,1,1]] </p>
<p>Output: 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="comment">// dfs寻找第一个岛屿，并把1全部赋值为2</span></span><br><span class="line">    <span class="keyword">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs寻找第二个岛屿，并把过程中经过的0赋值为2</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();   <span class="comment">//n个临近海域搜索，完结后进入第二级海域</span></span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n</span></span></span><br><span class="line"><span class="function"><span class="params">         , <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--points队列里面存的是临近第一个小岛的海域-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>1、有序数列的查找</p>
<p>返回元素第一次出现的位置和最后一次出现的位置</p>
<span id="more"></span>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mylower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myupper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> lower = <span class="built_in">mylower_bound</span>(nums, target);</span><br><span class="line">	<span class="keyword">int</span> upper = <span class="built_in">myupper_bound</span>(nums, target) - <span class="number">1</span>; <span class="comment">// 这里需要减1位</span></span><br><span class="line">	<span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">		<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2 = <span class="built_in">searchRange</span>(v1,i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;含有 7 的区间为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; v2.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v2[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、二分查找的开区间和闭区间"><a href="#2、二分查找的开区间和闭区间" class="headerlink" title="2、二分查找的开区间和闭区间"></a>2、二分查找的开区间和闭区间</h3><p>一般查找分为 左闭右开 和 左闭右闭两种情况：</p>
<p><a href="https://blog.csdn.net/blue_coffeei/article/details/91476091">https://blog.csdn.net/blue_coffeei/article/details/91476091</a></p>
<h3 id="3、牛顿迭代法（开平方）"><a href="#3、牛顿迭代法（开平方）" class="headerlink" title="3、牛顿迭代法（开平方）"></a>3、牛顿迭代法（开平方）</h3><p>其公式为 xn+1 = xn − f (xn)/ f ′ (xn)。给 定 f (x) = x 2 − a = 0，这里的迭代公式为 xn+1 = (xn + a/xn)/2，其代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> x = a;</span><br><span class="line">		<span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">			x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、旋转数组查找法"><a href="#4、旋转数组查找法" class="headerlink" title="4、旋转数组查找法"></a>4、旋转数组查找法</h3><p>1.查找旋转数组的最小值</p>
<p>Input: nums = [2,5,6,0,0,1,2],</p>
<p>思路：三种情况</p>
<p>1、nums [mid] &lt; nums [r] =&gt; mid 位于右区间，右区间有序</p>
<p>2、nums[mid] &gt; nums [r] =&gt; mid 位于左区间，左区间有序</p>
<p>3、nums[mid] = nums[r] =&gt; 重复的值，r - -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>,<span class="built_in">len</span>(numbers-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> left&lt;right:</span><br><span class="line">     mid = (left+right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> numbers[mid] &gt; numbers[right]; <span class="string">&quot;&quot;&quot;位于左区间&quot;&quot;&quot;</span></span><br><span class="line">       left = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elif</span> numbers[mid] &lt; numbers[right]; <span class="string">&quot;&quot;&quot;位于右区间&quot;&quot;&quot;</span></span><br><span class="line">       right = mid;    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> numbers[left]</span><br></pre></td></tr></table></figure>

<!--因为是查找最小值，区间的收缩会不一样-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/05/hello-world/</url>
    <content><![CDATA[<p>临阵磨枪一波，搞个博客。</p>
<blockquote>
<p>入坑教程：<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a></p>
</blockquote>
]]></content>
  </entry>
</search>
