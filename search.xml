<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/07/09/2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h1><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1 运算符"></a>1 运算符</h2><span id="more"></span>

<ul>
<li><p>单目运算符</p>
<blockquote>
<p>++ – ! ~ 只需要一个操作数</p>
</blockquote>
</li>
<li><p>算术运算符</p>
<blockquote>
<p>++ – + - * / %</p>
</blockquote>
</li>
<li><p>关系运算符</p>
<blockquote>
<p>&lt; &gt;=  &lt;=  !=  ==    </p>
</blockquote>
<p>  <em><strong>①</strong></em>关系运算符连接的表达式叫做 <strong>关系表达式</strong><br>  <em><strong>②</strong></em>,5&gt;4&gt;3这个表达式和数学的5&gt;4&gt;3的含义是不一样的。c语言是（5&gt;4）=1 &gt;3   </p>
</li>
<li><p>逻辑运算符</p>
<blockquote>
<p>! &amp;&amp; ||<br>  优先级: ! &gt; &amp;&amp; &gt; ||  </p>
</blockquote>
<p>  <strong>注</strong><font color = red> c语言运算符是惰性的</font>  例如：<br>  A&amp;&amp;B&amp;&amp;C 只要A为0了，整体就为0了，后面不需要比较了。</p>
</li>
<li><p>条件运算符</p>
<blockquote>
<p>?:  例如：<br>  score &gt; 100?’E’:score&gt;=90?’A’:score&gt;=60?’B’:score&lt;0?’E’:’C’;</p>
</blockquote>
</li>
<li><p>赋值运算符  </p>
<blockquote>
<p>= 优先级直逗号高，排倒数第二  </p>
</blockquote>
<p> <strong>赋值运算符的基本规则：</strong><br> <em><strong>①</strong></em>赋值运算符的<strong>左边</strong>(左操作数)必须是一个<strong>可写的地址</strong>(左值)<br> <em><strong>②</strong></em>一些例子 如：  </p>
</li>
<li><p>逗号运算符</p>
<blockquote>
<p>,  </p>
</blockquote>
<p>  <strong>表达式1</strong>,<strong>表达式2</strong>,….<strong>表达式n</strong>;<br>  <strong>求值顺序</strong>,先计算表达式1的值,再计算表达式2的值….最后计算表达式n<strong>整个逗号表达式的值是表达式n的值</strong></p>
</li>
<li><p>指针运算符(*,&amp;)</p>
</li>
<li><p>求字节数量运算符(sizeof)</p>
</li>
<li><p>分量运算符(结构体)<br><font color = red size = 5> 运算符的优先级</font><br><img src="https://i.loli.net/2021/07/09/mp6rDQEBF7zStdU.jpg" alt="1.jpg"></p>
<h2 id="2、表达式"><a href="#2、表达式" class="headerlink" title="2、表达式"></a>2、表达式</h2><h2 id="3、位运算"><a href="#3、位运算" class="headerlink" title="3、位运算"></a>3、位运算</h2></li>
</ul>
<ul>
<li>&amp; <em><strong>按位与</strong></em><blockquote>
<p>结论:<br>  一个bit位与0进行“按位与”操作,结果为0<br>  一个bit位与1进行“按位与”操作,结果不变</p>
</blockquote>
</li>
<li>|    <em><strong>按位或</strong></em>  <blockquote>
<p>结论:<br>  一个bit位与0进行“按位或”操作,结果不变<br>  一个bit位与1进行“按位或”操作,结果置1</p>
</blockquote>
</li>
<li>^    <em><strong>按位异或</strong></em> <blockquote>
<p>结论:<br>  一个bit位与0进行“按位异或”操作,结果不变<br>  一个bit位与1进行“按位异或”操作,结果反转<br>  例子：<br>  <strong>7</strong>取出整数变量x中第p位开始的n个bit位<br>  <strong>8</strong>将x中第p位开始的n个bit位设置为y(整数变量)中的最右边的n位的值，x的其余各位保持不变<br>  <strong>9</strong>将x中第p位开始的n个bit位取反，其余各位保持不变  </p>
</blockquote>
</li>
<li>~    按位取反   </li>
<li>&lt;&lt; 按位左移  <blockquote>
<p>同右移</p>
</blockquote>
</li>
<li>(&gt;&gt;) 按位右移  <blockquote>
<p>双目运算符,所有的bit位整体向右边移动a&gt;&gt;n,把a按照bit整体向右边移动n位(在左边补n个0)移位之后,低位舍弃.<br>  <em><strong>对应有符号数,高位补符号位.对于无符号数,高位补0</strong></em></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>8-02 随笔</title>
    <url>/2021/08/02/8-02-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="1、Linux-程序设计"><a href="#1、Linux-程序设计" class="headerlink" title="1、Linux 程序设计"></a>1、Linux 程序设计</h1>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux那些命令</title>
    <url>/2021/07/14/Linux%E9%82%A3%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux那些命令-1"><a href="#Linux那些命令-1" class="headerlink" title="Linux那些命令(1)"></a>Linux那些命令(1)</h1><span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcvf ***.tar.gz filelist     //打包</span><br><span class="line">tar -xvf ***.tar.gz -C 目标文件   //解压</span><br><span class="line">find ./  -regex &quot;.*\.[ch]&quot;     //查找该目录下的所有.c和.h文件</span><br><span class="line">find ./  -regex &quot;.*\.[ch]&quot; -exec tar -zcvf hello.tar.gz &#123;&#125; +   //打包所有.c和.h文件</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Yu</title>
    <url>/2021/07/08/Yu/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1、c语言数据类型"><a href="#1、c语言数据类型" class="headerlink" title="1、c语言数据类型"></a><em><strong>1、c语言数据类型</strong></em></h2><span id="more"></span>

<ol>
<li><p>数据类型 </p>
<ul>
<li><p>整形  </p>
<blockquote>
<p>(signed) char/ unsigned char  —&gt;<strong>字符型</strong><br>char 占 1byte(字节) = 8 bits  </p>
</blockquote>
<blockquote>
<p>(signed) short/ unsigned short  —&gt;<strong>短整型</strong><br>short 占 2byte(字节) = 16 bits</p>
</blockquote>
<blockquote>
<p>(signed) int/ unsigned int  —&gt;<strong>整型</strong><br>int 占 4byte(字节) = 32 bits</p>
</blockquote>
<blockquote>
<p>(signed) long/ unsigned long  —&gt;<strong>长整型</strong><br>在32位机器值 long 占 4byte(字节) = 32 bits<br>在64位机器值 long 占 8byte(字节) = 64 bits</p>
</blockquote>
</li>
<li><p>浮点型  </p>
<blockquote>
<p>单精度 float 4byte<br>双精度 double 8byte<br>长精度 long double 12byte  </p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="2、常量与变量"><a href="#2、常量与变量" class="headerlink" title="2、常量与变量"></a><em><strong>2、常量与变量</strong></em></h2><h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a><em><strong>2.1 常量</strong></em></h3><ul>
<li><p>整型常量  </p>
<pre><code>二进制(8421)     
    八进制(以0开头的都是八进制) 136   ----&gt; 001 011 110  
    16进制(以0x/0X开头的)  
    10进制(没有特殊说明都是10进制)
</code></pre>
</li>
<li><p>浮点型常量</p>
<pre><code>带小数的  
    1.2  
    1.2e-3 ----&gt;0.0012  
</code></pre>
</li>
<li><p>字符型常量  </p>
<pre><code>保存的不是形状,是ASCII码.  
    字符&lt;------&gt;整数
</code></pre>
</li>
<li><p>枚举常量</p>
</li>
</ul>
<h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a><em><strong>2.2 变量</strong></em></h3><p><strong>2.2.1.变量的定义</strong>  </p>
<blockquote>
<p>变量类型 变量名;<br>变量的属性(占用多大的空间,取值范围—-&gt;类型)    </p>
</blockquote>
<p><strong>2.2.2.signed/unsigned</strong> </p>
<blockquote>
<p>signed:最高位是符号位,其他都是数值位<br>unsigned:都是数值位  </p>
</blockquote>
<p><strong>2.2.3.变量的保存</strong>      </p>
<blockquote>
<p>存储的是二进制补码<br>原码&lt;—–&gt;补码<br>正数:原码本身<br>负数:原码的绝对值,取反+1(二进制)  </p>
</blockquote>
<h2 id="3、整形数据的存储"><a href="#3、整形数据的存储" class="headerlink" title="3、整形数据的存储"></a><em><strong>3、整形数据的存储</strong></em></h2><ul>
<li><em><strong>3.1 整形数据的存储方法</strong></em></li>
</ul>
<ol>
<li>整形的存储方法<ul>
<li>正数<br>正数的补码就是本身的二进制 <strong>补码=原码</strong></li>
<li>负数<br><strong>原码变补码</strong><br><strong>符号位不变，数据位取反</strong>  原码的绝对值 取反 加一 比如：<br>-13<br>绝对值：13 0000 1101<br>取反：1111 0011<br>加一：1111 0100<br>在计算机中存储的就是 1111 0100<br><strong>补码变原码</strong><br>short a = 32767;<br>short b = a+2;<br>printf(“%d\n”,b);<br>0111 1111 1111 1111 + 0000 0000 0000 0010 = 1000 0000 0000 0001 存储码<br>补码转原码：<strong>符号位不变，数据位取反</strong><br>补码减一 取反 1111 1111 1111 1111 = -32767<br><font color=red size=3><strong>总结：在进行运算的时候，都是补码在进行运算，正数的补码等于原码，故不必再进行转码；当补码为负数或数据溢出时，需将补码转化为原码。</strong></font></li>
</ul>
</li>
</ol>
<ul>
<li><p><em><strong>3.2 signed/unsigned</strong></em></p>
</li>
<li><p><em><strong>3.3 关于整型数据的赋值问题,C语言的标准建议</strong></em>    </p>
<h3 id="3-3-1"><a href="#3-3-1" class="headerlink" title="3.3.1"></a>3.3.1</h3><ul>
<li><p><font color = red size =3><strong>长的赋值给短的（不管有没有符号）</strong> </font></p>
<blockquote>
<p>低字节直接拷贝，高字节直接丢弃</p>
</blockquote>
</li>
</ul>
<h3 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h3><ul>
<li><p><font color = red size=3><strong>短的赋值给长的</strong> </font> </p>
<blockquote>
<p>有符号（signed）那么低字节直接拷贝,高字节全部补符号位<br>无符号（unsigned）那么低字节直接拷贝,高字节全部补0       </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;font color=red size=3&gt;**特例:** **当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型**&lt;/font&gt;
</code></pre>
<ul>
<li><em><strong>3.4 溢出问题</strong></em>  <pre><code>溢出其实就是一个计算值
长----&gt;短
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Yu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/05/hello-world/</url>
    <content><![CDATA[<p>临阵磨枪一波，搞个博客。</p>
<blockquote>
<p>入坑教程：<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>GEC6818</title>
    <url>/2021/07/16/GEC6818/</url>
    <content><![CDATA[<h2 id="GEC6818-7-16"><a href="#GEC6818-7-16" class="headerlink" title="GEC6818_7_16"></a>GEC6818_7_16</h2><p>又GEC6818</p>
<span id="more"></span>

<blockquote>
<p><em>碎碎念</em>：(文章封面) 为 vscode 的美化，安装background插件和***代码发光插件</p>
</blockquote>
<h3 id="一、交叉编译"><a href="#一、交叉编译" class="headerlink" title="一、交叉编译"></a>一、交叉编译</h3><h3 id="1、Linux-子系统安装交叉编译器"><a href="#1、Linux-子系统安装交叉编译器" class="headerlink" title="1、Linux 子系统安装交叉编译器"></a>1、Linux 子系统安装交叉编译器</h3><p>(1) 把交叉编译工具链的压缩包，拷贝到你的linux系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure>

<p>(2) 在linux系统下，把交叉编译工具包，解压到一个合适的目录下(不能是共享目录)</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;usr&#x2F;local&#x2F;arm</span><br><span class="line">sudo tar xvf gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabi.tar.xz -C &#x2F;usr&#x2F;local&#x2F;arm</span><br></pre></td></tr></table></figure>

<p>=&gt;上面两步骤做完后，就可以”交叉编译”了，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabi&#x2F;bin&#x2F;arm-linux-gnueabi-gcc test.c -o sb</span><br></pre></td></tr></table></figure>

<p>(3) 修改环境变量PATH</p>
<p>交叉编译的命令的路径太长了，SO,我们需要把交叉编译的那个路径，加到环境变量PATH中去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabi&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>如果在终端运行上面那条命令，仅改变当前终端的那个环境变量，什么意思呢？</p>
<p>在其他终端或终端重启之后，PATH会恢复原来的值。我们希望每次一开机，每个用户都是上面的那个值，怎么办呢?</p>
<p>/etc/profile 这个文件是系统启动后，每个用户首先会执行的。</p>
<p> 如果把环境变量的值，在这个文件中，修改，那么系统中所有的用户都共享的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;profile</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-5.5.0-2017.10-x86_64_arm-linux-gnueabi&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>​     把上面这条指令加入到 /etc/profile的最后一行</p>
<blockquote>
<p>串口工具：serials to USB :  ch340 USB转串口驱动</p>
</blockquote>
<h3 id="二、U盘传输"><a href="#二、U盘传输" class="headerlink" title="二、U盘传输"></a>二、U盘传输</h3><p><a href="https://jingyan.baidu.com/article/cbf0e500a9731e2eab289371.html">如何使用fdisk进行分区-百度经验 (baidu.com)</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 建立分区表</span><br><span class="line">        &quot;分区就是你分几个盘&quot;</span><br><span class="line">        fdisk</span><br><span class="line">        如:</span><br><span class="line">            fdisk  &#x2F;dev&#x2F;sda</span><br><span class="line">(2) 格式化</span><br><span class="line">        把“文件系统的元数据”写入到分区的前面</span><br><span class="line">        如:</span><br><span class="line">            mkfs.vfat &#x2F;dev&#x2F;sda1</span><br><span class="line">(3) 挂载</span><br><span class="line">        把U盘(硬盘)分区的文件系统  挂载到操作系统的某个路径下面去。</span><br><span class="line">        如:</span><br><span class="line">            mount -t vfat  &#x2F;dev&#x2F;sda1   &#x2F;mnt</span><br><span class="line">(4) xie载(“弹出”)</span><br><span class="line">        umount &#x2F;dev&#x2F;sda1</span><br><span class="line">        or</span><br><span class="line">        umount &#x2F;mnt</span><br></pre></td></tr></table></figure>



<h3 id="三、网络工具"><a href="#三、网络工具" class="headerlink" title="三、网络工具"></a>三、网络工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 配置虚拟机ubuntu的ip地址</span><br><span class="line">        把虚拟机的网络配置为“桥接模式”：让虚拟机系统有一个独立的IP</span><br><span class="line"></span><br><span class="line">        然后再到ubuntu里面的系统，设置网络IP</span><br><span class="line">            静态IP: &lt;&lt;&lt;&lt;&lt;</span><br><span class="line">            动态IP： DHCP</span><br><span class="line">        练习:</span><br><span class="line">            如何判断一台机子网络是否与另外一台机子在物理上是呢?</span><br><span class="line">                ping 另外一台机子的ip或域名</span><br><span class="line">            如:</span><br><span class="line">                ping 192.168.2.1</span><br><span class="line">                ping www.baidu.com</span><br><span class="line"></span><br><span class="line">    (2) 开发板网络配置</span><br><span class="line">        开发板上面没有图形化的网络配置工具，只有命令行。</span><br><span class="line"></span><br><span class="line">        配置网络的命令</span><br><span class="line">            ifconfig</span><br><span class="line">        配置IP</span><br><span class="line">            ifconfig eth0 192.168.2.253 netmask 255.255.255.0 up</span><br><span class="line">        </span><br><span class="line">        配置网卡的MAC地址(物理地址)</span><br><span class="line">            ifconfig eth0 hw ether 12:E1:DE:08:06:F4</span><br><span class="line"></span><br><span class="line">        每次开机的时候，你都需要配置你开发板的网络:</span><br><span class="line">            ifconfig eth0 down</span><br><span class="line">            ifconfig eth0 hw ether 12:E1:DE:08:06:F4</span><br><span class="line">            ifconfig eth0 192.168.2.253 netmask 255.255.2550 up </span><br><span class="line"></span><br><span class="line">        如果，你每次开机都需要手动运行上面那三条命令，是不是显得很LOW。</span><br><span class="line">        开发板上面的Linux系统，每次开机的时候，都会执行一个脚本(启动脚本)</span><br><span class="line">            &#x2F;etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">        这个脚本，它会把 &#x2F;etc&#x2F;init.d&#x2F;这个目录下面的 所有的</span><br><span class="line">            Sxxxx.sh 文件执行一遍</span><br><span class="line">        SO,你如果有些命令或配置想要开机就自动执行，</span><br><span class="line">        你就可以写一个Sxxxx.sh 脚本，放在开发板的 &#x2F;etc&#x2F;init.d这个目录下面。</span><br><span class="line">        如:</span><br><span class="line">        Start.sh</span><br><span class="line"></span><br><span class="line">        &#96;&#96;&#96;sh</span><br><span class="line">        #!&#x2F;bin&#x2F;sh</span><br><span class="line">        ifconfig eth0 down</span><br><span class="line">        ifconfig eth0 hw ether 12:E1:DE:08:06:F4</span><br><span class="line">        ifconfig eth0 192.168.2.253 netmask 255.255.2550 up </span><br><span class="line"></span><br><span class="line">        telnetd &amp;</span><br></pre></td></tr></table></figure>

<pre><code>    chmod +x Start.sh

(3) 用tftp协议来在PC机和开发板之间传输文件
    tftp是用UDP协议做的一个网络传输文件的应用层协议。

    PC &lt;-------------&gt; ARM开发板
    tftpd               tftp
    Server              Client

    (3.1) ubuntu tftpd服务器的配置
        安装tftpd:
            sudo apt-get install tftpd-hpa
        启动:
            sudo service tftpd-hpa start
        重启:
            sudo service tftpd-hpa restart
        停止:
            sudo service tftpd-hpa stop

        配置tftpd的服务
            tftpd的配置文件在 /etc/default/tftpd-hpa
           
            TFTP_USERNAME=&quot;tftp&quot;
            TFTP_DIRECTORY=&quot;/home/china/tftpboot&quot;
            TFTP_ADDRESS=&quot;0.0.0.0:69&quot;
            TFTP_OPTIONS=&quot;-l -c -s&quot;

    (3.2) tftp 客户端(开发板)下载和上传命令
        下载：
            tftp -g -r sb.txt  192.168.2.251
                -g get 获取，下载
                -r remote 指定远程服务器上的文件名(要下载的文件)
        上传:
            tftp -p -l you_are_sb.txt 192.168.2.251
                -p put 上传，推送
                -l local指定本地文件名(要上传的文件)
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、网络控制GEC6818"><a href="#四、网络控制GEC6818" class="headerlink" title="四、网络控制GEC6818"></a>四、网络控制GEC6818</h3><p>telnetd  服务</p>
<p>Linux 系统作为服务器   telnetd IP  连接开发板 </p>
<p>GEC6818需作为客户端  开机后台开启telnetd  服务</p>
<h3 id="五、umask"><a href="#五、umask" class="headerlink" title="五、umask"></a>五、umask</h3><p>指定新建文件的权限</p>
]]></content>
      <categories>
        <category>GEC6818</category>
      </categories>
      <tags>
        <tag>GEC6818</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>1、有序数列的查找</p>
<p>返回元素第一次出现的位置和最后一次出现的位置</p>
<span id="more"></span>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mylower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myupper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> lower = <span class="built_in">mylower_bound</span>(nums, target);</span><br><span class="line">	<span class="keyword">int</span> upper = <span class="built_in">myupper_bound</span>(nums, target) - <span class="number">1</span>; <span class="comment">// 这里需要减1位</span></span><br><span class="line">	<span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">		<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2 = <span class="built_in">searchRange</span>(v1,i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;含有 7 的区间为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; v2.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v2[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、二分查找的开区间和闭区间"><a href="#2、二分查找的开区间和闭区间" class="headerlink" title="2、二分查找的开区间和闭区间"></a>2、二分查找的开区间和闭区间</h3><p>一般查找分为 左闭右开 和 左闭右闭两种情况：</p>
<p><a href="https://blog.csdn.net/blue_coffeei/article/details/91476091">https://blog.csdn.net/blue_coffeei/article/details/91476091</a></p>
<h3 id="3、牛顿迭代法（开平方）"><a href="#3、牛顿迭代法（开平方）" class="headerlink" title="3、牛顿迭代法（开平方）"></a>3、牛顿迭代法（开平方）</h3><p>其公式为 xn+1 = xn − f (xn)/ f ′ (xn)。给 定 f (x) = x 2 − a = 0，这里的迭代公式为 xn+1 = (xn + a/xn)/2，其代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> x = a;</span><br><span class="line">		<span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">			x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、旋转数组查找法"><a href="#4、旋转数组查找法" class="headerlink" title="4、旋转数组查找法"></a>4、旋转数组查找法</h3><p>1.查找旋转数组的最小值</p>
<p>Input: nums = [2,5,6,0,0,1,2],</p>
<p>思路：三种情况</p>
<p>1、nums [mid] &lt; nums [r] =&gt; mid 位于右区间，右区间有序</p>
<p>2、nums[mid] &gt; nums [r] =&gt; mid 位于左区间，左区间有序</p>
<p>3、nums[mid] = nums[r] =&gt; 重复的值，r - -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>,<span class="built_in">len</span>(numbers-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> left&lt;right:</span><br><span class="line">     mid = (left+right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> numbers[mid] &gt; numbers[right]; <span class="string">&quot;&quot;&quot;位于左区间&quot;&quot;&quot;</span></span><br><span class="line">       left = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elif</span> numbers[mid] &lt; numbers[right]; <span class="string">&quot;&quot;&quot;位于右区间&quot;&quot;&quot;</span></span><br><span class="line">       right = mid;    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> numbers[left]</span><br></pre></td></tr></table></figure>

<!--因为是查找最小值，区间的收缩会不一样-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx那些事</title>
    <url>/2021/06/04/nginx%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="Nginx那些事儿"><a href="#Nginx那些事儿" class="headerlink" title="Nginx那些事儿"></a>Nginx那些事儿</h2><p>nginx简介：<strong>高性能的HTTP</strong>和<strong>反向代理Web服务器</strong>，提供各种服务 IMAP/POP3/SMTP 等等服务。</p>
<span id="more"></span>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>(1)正向代理:在客户端需要配置代理服务器，通过代理服务器进行互联网访问</p>
<p>(2)反向代理：客户端不需要配置 反向代理服务器 。 对外，反向代理服务器和目标是一个服务器</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>QT那些事儿(1)</title>
    <url>/2021/05/15/QT%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-1/</url>
    <content><![CDATA[<h2 id="QT那些事儿（1）"><a href="#QT那些事儿（1）" class="headerlink" title="QT那些事儿（1）"></a>QT那些事儿（1）</h2><h3 id="1、QT是神马？"><a href="#1、QT是神马？" class="headerlink" title="1、QT是神马？"></a>1、QT是神马？</h3><span id="more"></span>

<blockquote>
<p><strong>关于QT的介绍呢，让我们乘上时光机</strong> <a href="https://zhuanlan.zhihu.com/p/140489718">https://zhuanlan.zhihu.com/p/140489718</a> <strong>一探究竟</strong></p>
</blockquote>
<p>QT呢，是C++御用图形用户界面应用程序框架，与 <u><strong>嵌入式Liunx</strong></u>，<strong>C++</strong> 的开发密不可分。</p>
<blockquote>
<p><strong>先学C++基础语法，基本数据类型，两个复合类型，几种主要的语句，类最基本的创建，构造，析构，就可以学Qt，在Qt中逐渐学会类的构建，类的特性，继承，多态等等，学Qt的时候慢慢感受类，能让你对类和面向对象有更深入的理解，而且可以模仿Qt框架类的实现，它本身就是C++的一个类群</strong></p>
</blockquote>
<h3 id="2、面向offer的编程"><a href="#2、面向offer的编程" class="headerlink" title="2、面向offer的编程"></a>2、面向offer的编程</h3><p>作为一名合格的程序员呢，应该有自己的一套核心技术栈，采集与某 app 的职位招聘信息</p>
<p>（1）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6f946ae4f77d3520011f.jpg"></p>
<p>（2）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6fcf6ae4f77d352323b8.jpg"></p>
<p>（3）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6ff26ae4f77d352524d9.jpg"></p>
<p><em><strong>高薪offer冲冲冲</strong> ✌</em></p>
]]></content>
      <tags>
        <tag>QT那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title>假期</title>
    <url>/2021/06/19/%E5%81%87%E6%9C%9F(1)/</url>
    <content><![CDATA[<h2 id="First-–-01-链表操作"><a href="#First-–-01-链表操作" class="headerlink" title="First – 01    (链表操作)"></a>First – 01    (链表操作)</h2><span id="more"></span>

<h3 id="1、vscode-连接ubuntu-连接虚拟机上的Ubuntu"><a href="#1、vscode-连接ubuntu-连接虚拟机上的Ubuntu" class="headerlink" title="1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :"></a>1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :</h3><ul>
<li><p><input checked="" disabled="" type="checkbox">  1、ubuntu 安装ssh :  sudo apt-get install ssh</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  2、 vscode 终端命令 :  ssh  (用户名)@ IP     //连接  （vscode安装ssh   client  插件）</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60dbd5795132923bf8015adc.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 3、虚拟机上网：网络桥接模式</li>
</ul>
<h3 id="2、递归版本的有序链表插入"><a href="#2、递归版本的有序链表插入" class="headerlink" title="2、递归版本的有序链表插入"></a>2、递归版本的有序链表插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Insert</span><span class="params">(Node *h,Node *p)</span>  <span class="comment">//递归方式插入有序链表  返回头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;= h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &gt; h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Insert(h-&gt;next,p); <span class="comment">//递归  最后吐出来的是头结点后面的位置</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、非递归的插入方法"><a href="#3、非递归的插入方法" class="headerlink" title="3、非递归的插入方法"></a>3、非递归的插入方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到插入位置</span></span><br><span class="line"><span class="comment">//分情况讨论  找到和没找到</span></span><br><span class="line"></span><br><span class="line">Node *pk = h;  <span class="comment">//pk指向</span></span><br><span class="line">Node *pr = <span class="literal">NULL</span>;  <span class="comment">//pr指向pk的前驱点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pk-&gt;data &gt;= p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pr = pk;</span><br><span class="line">    pk = pk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pk == <span class="literal">NULL</span>)   <span class="comment">//最后一个</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    pr-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pk == h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        h = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中间插入</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        pr-&gt;next =p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为x的结点</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除算法:</span></span><br><span class="line">    <span class="comment">//1. 找到要删除的结点</span></span><br><span class="line">    <span class="comment">// 遍历链表找到值为x的结点(要删除的结点)px及它前驱结点pr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 分情况删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//px指向要删除的结点</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>; <span class="comment">//pr指向px的前驱结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//px每次搜索开始的那个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        px = ps;</span><br><span class="line">        <span class="keyword">while</span> (px)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps = px-&gt;next; <span class="comment">//下一次搜索的起点就是要删除的结点的下一个!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == h)</span><br><span class="line">        &#123;</span><br><span class="line">            h = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;next = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X_v2</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        Node *px = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Delete_X_v2(h,x);  <span class="comment">//如果后面还有待删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Delete_X_v2(h-&gt;next, x);   <span class="comment">//递归删除中间的结点</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h3><p>正负数排序</p>
<p>相对位置不变，时间复杂度O(n),不能申请新的空间</p>
<p>算法1：依次摘除负数结点，链接剩下的。成功排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Adjust</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *first = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的第一个结点</span></span><br><span class="line">    Node *last = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的最后一个结点</span></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//指向原链表中“下一个要摘除的结点”</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向px前面的那个结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//下一次搜索的起始结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//&quot;查找下一个负数结点&quot;</span></span><br><span class="line">        px = ps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (px)   <span class="comment">//第一次找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//“查找的结果只有两种情况：要么没有找到，要么找到了”</span></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)  <span class="comment">//遍历完成，没有找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原链表上已经不存在“负数结点”啦</span></span><br><span class="line">            <span class="comment">//这个时候，你需要做的事情是：把负数链表和剩余的</span></span><br><span class="line">            <span class="comment">// 原链表链起来就可以了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last-&gt;next = h;</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ps = px-&gt;next; <span class="comment">//下一次搜索的起始结点。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//“找到下一个负数结点啦”</span></span><br><span class="line">            <span class="comment">//(1)先把该负数结点从原链表中摘除下来</span></span><br><span class="line">            <span class="keyword">if</span> (px == h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点是原链表中的“第一个结点”</span></span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点不是原链表中的第一个结点</span></span><br><span class="line">                pr-&gt;next = px-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)把该负数结点按“尾插法”加入到新负数链表中去</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                first = px;</span><br><span class="line">                last = px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; </span><br><span class="line">                last-&gt;next = px;</span><br><span class="line">                last = px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、逆转链表</p>
<ol start="2">
<li> 就地逆置一个单链表<br> 例子:<pre><code> h:  1 5 3 4 
 =&gt;
 h: 4 3 5 1 
</code></pre>
 要求：<pre><code> 不能新申请结点的空间
</code></pre>
</li>
</ol>
<p>​    算法一:<br>​        1. 把原链表上的结点一一(从第一个到最后一个)摘除下来<br>​                2. 把摘除下来的结点，按“头插法”加入到新链表中</p>
<p>​        p 指向新摘除的结点<br>​        </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first =<span class="literal">NULL</span>; <span class="comment">//指向新链表的第一个结点</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (h)</span><br><span class="line">​        &#123;</span><br><span class="line">​            p = h;</span><br><span class="line">​            h = h-&gt;next;</span><br><span class="line">​            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">​            &#123;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line">​            <span class="keyword">else</span></span><br><span class="line">​            &#123;</span><br><span class="line">​                p-&gt;next = first;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure>

<p>​    算法二:<br>​        把原链表“一分为二”：<br>​            第一个结点为链表1， h1指向第一个链表的第一个结点<br>​            其余结点为链表2    h2指向后面那个链表的第一个结点</p>
<p>​        只考虑h1和h2这两个结点，逆置，h2放置在h1的前面</p>
<p>​            p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​            h2-&gt;next = h1;<br>​            h1 = h2;<br>​            h2 = p;</p>
<p>​            h1 = h;<br>​            h2 = h-&gt;next ;<br>​            h-&gt;next = NULL;</p>
<p>​            while (h2)<br>​            {<br>​                p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​                h2-&gt;next = h1;<br>​                h1 = h2;<br>​                h2 = p;</p>
<p>​            }</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	Node*</span><br><span class="line">​	reverse(Node* h)</span><br><span class="line">​	&#123;</span><br><span class="line">​	         h1 = h;</span><br><span class="line">​            h2 = h-&gt;next ;</span><br><span class="line">​            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">while</span> (h2)</span><br><span class="line">​            &#123;</span><br><span class="line">​                p = h2-&gt;next; <span class="comment">//先保存后面那个链表的第二个结点</span></span><br><span class="line">​                h2-&gt;next = h1;</span><br><span class="line">​                h1 = h2; </span><br><span class="line">​                h2 = p;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line">​	</span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>双链表的打印方式可以用递归的方法实现 先递归打印 p-&gt;next，然后打印本身</p>
</blockquote>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>假期4</title>
    <url>/2021/07/07/%E5%81%87%E6%9C%9F(4)/</url>
    <content><![CDATA[<h2 id="这孩子打小就聪明"><a href="#这孩子打小就聪明" class="headerlink" title="这孩子打小就聪明"></a>这孩子打小就聪明</h2><span id="more"></span>

<blockquote>
<p><em>碎碎念</em>：(文章封面) 为电脑桌面，永远的龙珠 (动漫)</p>
</blockquote>
<p>关于二叉树的递归问题</p>
<h3 id="1、求出二叉树的高度"><a href="#1、求出二叉树的高度" class="headerlink" title="1、求出二叉树的高度"></a>1、求出二叉树的高度</h3><p>递归思路：设置一个宏，比较两个数的最大值   返回左子树函数调用和右子树函数调用加1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b) ?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX(level(t-&gt;lchild),level(t-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、求出数的最大结点"><a href="#2、求出数的最大结点" class="headerlink" title="2、求出数的最大结点"></a>2、求出数的最大结点</h3><p>递归思路:如果右子树存在，返回右子树的函数调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Bitree *<span class="title">max</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、删除整个二叉树"><a href="#3、删除整个二叉树" class="headerlink" title="3、删除整个二叉树"></a>3、删除整个二叉树</h3><p>递归思路：删除左子树，删除右子树，删除本身结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、判断一棵二叉树是否为排序二叉树"><a href="#4、判断一棵二叉树是否为排序二叉树" class="headerlink" title="4、判断一棵二叉树是否为排序二叉树"></a>4、判断一棵二叉树是否为排序二叉树</h3><p>思路:1、中序遍历二叉树，如果得出的数组为升序序列，为二叉排序树</p>
<p>2、左子树是排序树 &amp;&amp; 右子树是排序树 &amp;&amp; 左子树最大值&lt;根&lt;右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、递归构造一棵二叉树"><a href="#5、递归构造一棵二叉树" class="headerlink" title="5、递归构造一棵二叉树"></a>5、递归构造一棵二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序创造二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data = c;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);  <span class="comment">//递归方法创建左子树</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);  <span class="comment">//递归方法创建右子树  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造方法: 为空的地方要用 &quot;0&quot; 填充</span></span><br></pre></td></tr></table></figure>

<h3 id="6、平衡二叉树-AVL-树"><a href="#6、平衡二叉树-AVL-树" class="headerlink" title="6、平衡二叉树(AVL)树"></a>6、平衡二叉树(AVL)树</h3><p>分四种情况：  //为了弄到平衡因子的情况，结点结构体需要加入高度的成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单向右旋   (往左子树加入时，插入结点小于左子树结点)  本身右旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">SingleRotateWithRight</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向左旋   (往右子树加入时，插入结点大于右子树结点) 本身左旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">SingleRotateWithLeft</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结点x进行一个“双向旋转(先左后右)平衡处理”  (往左子树加入时，加入的结点大于左子树结点值) 左子树左旋，本身右旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">DoubleRotateLeftRight</span><span class="params">(BiTNode *x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结点x进行一个“双向旋(先右后左)平衡处理”    (往右子树加入时，加入的结点小于右子树结点值) 右子树右旋，本身左旋</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">DoubleRotateRightLeft</span><span class="params">(BiTNode *x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所有的左旋右旋操作都在插入时进行操作流程。</p>
<p>递归插入 - &gt;  递归设置高度值 -&gt; 根据平衡因子来判断左右旋的操作</p>
<p>tips:左右旋时要实时更新高度数值,先更新原来根节点的高度数值，然后更新新的根节点的高度数值</p>
<h3 id="7、最短路径"><a href="#7、最短路径" class="headerlink" title="7、最短路径"></a>7、最短路径</h3><p>三个辅助数组</p>
<ol>
<li><p>数组s[n]  标记数组。  s[i] =1  源点v到vi的最短距离是否求出   s[0]  表示没有求出</p>
</li>
<li><p>Dist[n]   最短距离</p>
</li>
<li><p>向量Path[n]  保存最短路径</p>
<p>两个步骤：找到最小值   -&gt; 更新  -&gt;找到最小值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(--n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> Min = VERY_BIG;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Vexnum;i++)     <span class="comment">//找到最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="number">0</span> &amp;&amp; Dist[i]&lt;Min)</span><br><span class="line">        &#123;</span><br><span class="line">            Min = Dist[i];</span><br><span class="line">            w = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Dist[w] + g-&gt;A[w][i] &lt; Dist[i])</span><br><span class="line">        &#123;</span><br><span class="line">            Dist[i] = Dist[w] + g-&gt;A[w][i];</span><br><span class="line">            <span class="built_in">strcpy</span>(Path[i],Path[w]);</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">strlen</span>(Path[w]);</span><br><span class="line">            Path[i][l] = g-&gt;V[i];</span><br><span class="line">            Path[i][l+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2021/07/01/Leetcode/</url>
    <content><![CDATA[<h2 id="复习-day01"><a href="#复习-day01" class="headerlink" title="复习(day01)"></a>复习(day01)</h2><span id="more"></span>

<h2 id="1、双指针"><a href="#1、双指针" class="headerlink" title="1、双指针"></a>1、双指针</h2><h3 id="（1）、合并两个有序数组"><a href="#（1）、合并两个有序数组" class="headerlink" title="（1）、合并两个有序数组"></a>（1）、合并两个有序数组</h3><p><img src="https://pic.imgdb.cn/item/60dda26d5132923bf8e4a2ad.png"></p>
<blockquote>
<p>将num1 扩容到两个数组合并大小三个指针，一个指向待操作的位置，一个指向num1,一个指向num2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> m,vector&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = m-- +n-- <span class="number">-1</span>; <span class="comment">//指向操作的位置</span></span><br><span class="line">    <span class="keyword">while</span>(m &gt;= <span class="number">0</span> &amp;&amp; n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums1[m] &gt; nums[n] ? nums1[m--]:nums2[n--]; <span class="comment">//两边开始走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--]; <span class="comment">//n1走完表示直接添加 n2要继续走完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）快慢指针（判断链表是否有环"><a href="#（2）快慢指针（判断链表是否有环" class="headerlink" title="（2）快慢指针（判断链表是否有环)"></a>（2）快慢指针（判断链表是否有环)</h3><p>判断链表是否有环，可以采用快慢指针，判断入环的位置，需要将快指针调到头结点，然后两个结点再走，碰到一起说明环的初始位置</p>
<h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="(3)滑动窗口"></a>(3)滑动窗口</h3><p>给定两个字符串 S 和 T，求 S 中包含 T 所有字符的最短连续子字符串的长度，同时要求时间 复杂度不得超过 O(n)。</p>
<p><img src="https://pic.imgdb.cn/item/60dda6535132923bf8f5a171.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;       <span class="comment">//记录T中的字符情况个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;  <span class="comment">//记录T中的字符情况</span></span><br><span class="line">    <span class="comment">// 先统计T中的字符情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        flag[T[i]] = <span class="literal">true</span>;  <span class="comment">//对应字符情况</span></span><br><span class="line">        ++chars[T[i]];    <span class="comment">//对应字符的个数分布</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动滑动窗口，不断更改统计数据</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若目前滑动窗口已包含T中全部字符，</span></span><br><span class="line">            <span class="comment">// 则尝试将l右移，在不影响结果的情况下获得最短子字符串</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="comment">//如果l缩小时，遇到待选字符，退还一个剩余量，并且cnt--,同时l++,r开始向右移动</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size &gt; S.<span class="built_in">size</span>()? <span class="string">&quot;&quot;</span>: S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><h3 id="（1）求开方"><a href="#（1）求开方" class="headerlink" title="（1）求开方"></a>（1）求开方</h3><p>设置一个非负整数，求它的开方，向下取整</p>
<p>例如： 8  -&gt;  2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(3)</title>
    <url>/2021/07/05/%E5%81%87%E6%9C%9F(3)/</url>
    <content><![CDATA[<h1 id="Third-03-树"><a href="#Third-03-树" class="headerlink" title="Third 03  树"></a>Third 03  树</h1><p>10.40</p>
<span id="more"></span>

<p>详细教程:<a href="https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a></p>
<h2 id="1、树和二叉树的基本概念"><a href="#1、树和二叉树的基本概念" class="headerlink" title="1、树和二叉树的基本概念"></a>1、树和二叉树的基本概念</h2><p>度为零的结点称之为叶子结点，度不为零的称之为非终端结点。最大层次为树的高度或深度</p>
<h2 id="2、二叉树-Binary-Tree"><a href="#2、二叉树-Binary-Tree" class="headerlink" title="2、二叉树(Binary Tree)"></a>2、二叉树(Binary Tree)</h2><p>每个结点最多只有两棵子树(不存在 度大于2 的结点) </p>
<p>满二叉树:在不增加树的高度下，没法在树中添加结点</p>
<p>完全二叉树:  (1) 除去最后一层，这棵树是满二叉树 (2)最后一层靠左边</p>
<p>二叉树性质:    </p>
<p>遍历方法：前序遍历，中序遍历，后序遍历都可以用递归来实现  层序遍历需要用到队列的方法</p>
<h3 id="1、tip-层序遍历-二叉树的层序遍历运用到队列操作"><a href="#1、tip-层序遍历-二叉树的层序遍历运用到队列操作" class="headerlink" title="1、tip:层序遍历:  二叉树的层序遍历运用到队列操作"></a>1、tip:层序遍历:  二叉树的层序遍历运用到队列操作</h3><ul>
<li><p>首先，根结点 1 入队；</p>
</li>
<li><p>根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；</p>
</li>
<li><p>队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；</p>
</li>
<li><p>队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；</p>
</li>
<li><p>不断地循环，直至队列内为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//根节点入队 Queue, 队列存储的类型应该是结点类型的</span></span><br><span class="line">Enqueue(q,p); </span><br><span class="line"><span class="keyword">while</span>(队列不为空)   <span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    p = Dequeue(q,p);  <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代方式实现遍历"><a href="#2、迭代方式实现遍历" class="headerlink" title="2、迭代方式实现遍历"></a>2、迭代方式实现遍历</h3><p>详细教程:</p>
<p><a href="https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen</a></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>1、首先创建一个栈，初始情况下，把根节点入栈</p>
</li>
</ul>
<p>​       2、进入循环<br>​       a）取栈顶元素（出栈）<br>​       b）访问该元素<br>​       c）如果该元素的右子树不为空，就入栈；如果左子树不为空也入栈，当栈为空时，遍历完成。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>​        1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​        2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​        3、当cur为空，（此时栈顶元素是目前的最左侧元素），出栈并访问<br>​        4、让cur指向刚刚被访问的节点的右子树，循环2、3、4步骤</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>​       1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​       2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​       3、当cur为空，取栈顶元素（如果栈顶元素被访问即被打印才可出栈，否则依然在栈里面），判断是否能够访问：<br>​       a）可以访问：<br>​       如果栈顶元素右子树为null，则可以访问<br>​       栈顶元素已经被访问过了，则可以访问，定义一个prev变量记录上一个被访问过的元素<br>​       b）不能访问：<br>​       让cur从栈顶元素的右子树出发继续进行1、2、3步骤</p>
<h2 id="3、二叉排序树的删除"><a href="#3、二叉排序树的删除" class="headerlink" title="3、二叉排序树的删除"></a>3、二叉排序树的删除</h2><p>步骤：先找到待删除的结点，然后据情况判断</p>
<p>1、如果结点没有孩子，直接删除</p>
<p>2、如果只有一个孩子，父结点直接指向孩子结点，删除该结点</p>
<p>3、如果 px 两个孩子都有，找到左子树的最大值作为”替罪羊” ，它的值赋给px，然后跳到开头处理px 的操作进行删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">DeleteX</span><span class="params">(BiTNode *t, TElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BiTNode *px = t; <span class="comment">//指向要删除的结点</span></span><br><span class="line">    BiTNode *pf; <span class="comment">//指向px的父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先找到要删除的结点</span></span><br><span class="line">    <span class="keyword">while</span> (px)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">delete_op:</span><br><span class="line">    <span class="comment">//! 找到了，分情况删除</span></span><br><span class="line">    <span class="keyword">if</span> (px-&gt;lchild == <span class="literal">NULL</span> &amp;&amp;  px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (px == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == pf-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//! px只有右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px只有左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">           pf-&gt;lchild = px-&gt;lchild;</span><br><span class="line">           px-&gt;lchild =<span class="literal">NULL</span>;</span><br><span class="line">           <span class="built_in">free</span>(px);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px左右孩子俱全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要找一个“替罪 yang”</span></span><br><span class="line">        <span class="comment">// 找左边最大值结点:左拐-&gt;右拐-&gt;右拐 ...</span></span><br><span class="line"></span><br><span class="line">        BiTNode *r = px;</span><br><span class="line"></span><br><span class="line">        pf  = px;</span><br><span class="line">        px = px-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (px-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r-&gt;data = px-&gt;data; <span class="comment">//!  </span></span><br><span class="line">        <span class="keyword">goto</span> delete_op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、树，二叉树。森林的转换"><a href="#4、树，二叉树。森林的转换" class="headerlink" title="4、树，二叉树。森林的转换"></a>4、树，二叉树。森林的转换</h2><p>树 &lt;-&gt; 二叉树 :   </p>
<ol>
<li><img src="https://pic.imgdb.cn/item/60e43c5c5132923bf8ce7b96.jpg"></li>
</ol>
<p>（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</p>
<p>2、森林转换成二叉树</p>
<ol>
<li>把每棵树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
<li><img src="https://pic.imgdb.cn/item/60e43e475132923bf8d67d22.jpg"></li>
</ol>
]]></content>
      <categories>
        <category>假期</category>
      </categories>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/07/12/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><span id="more"></span>

<h2 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h2><p><img src="https://pic.imgdb.cn/item/60ec3d485132923bf8c2230d.gif"></p>
<p>步骤：选中一个key每次都是从左边开始 , 先从它的右边开始遍历，找到比它小的，再从左边找到比它大的。然后作为分界点，左边递归，右边递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = l,last = r,key = a[first];</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[last] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            last ++;</span><br><span class="line">        &#125;</span><br><span class="line">        a[first] = a[last];</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[first] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            first --;</span><br><span class="line">        &#125;</span><br><span class="line">        a[last] = a[first];</span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;</span><br><span class="line">    quick(a,l,first);</span><br><span class="line">    quick(a,first+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h2>]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(5)</title>
    <url>/2021/07/13/%E5%81%87%E6%9C%9F(5)/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之旅(1)</title>
    <url>/2021/05/09/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-1/</url>
    <content><![CDATA[<h1 id="学习之旅-1"><a href="#学习之旅-1" class="headerlink" title="学习之旅(1)"></a>学习之旅(1)</h1><p>本篇章记录自己的学习生活。至于有多少后序呢，，，，，，</p>
<span id="more"></span>

<p>写博客嘞，找点素材，有时间把博客功能丰富一下。作为一名学习参与者，记录一下近期的学习的晋升之旅</p>
<p><em>现阶段呢，还是以啃书为主。各种书的资源呢，也许我会上传到github</em></p>
<h2 id="1、C-的学习"><a href="#1、C-的学习" class="headerlink" title="1、C++的学习"></a>1、C++的学习</h2><p>先说一下对学习C++的印象哈，语言的学习嘛，多而杂。最近在啃那个《Primer C++》</p>
<p>就这：</p>
<p><img src="https://pic.imgdb.cn/item/6097861cd1a9ae528f259d63.png"></p>
<p>有人会说啊，这个这个语言不就那几个循环啊，条件判断什么的嘛，过一遍就行。这样下去是不行滴昂，比如说，变量声明和定义的区别，作用域的理解啊。。。巴拉巴拉，语言的学习呢，还是要细致一点滴。经过C语言学习的惨痛教训呢(当时没认真听课)，深刻认识到语言的学习要细致入微。这本书呢，还是C++入门级别 &gt;__&lt;，别急，慢慢来，时间多的很。</p>
<blockquote>
<p><a href="https://light-city.club/sc/">https://light-city.club/sc/</a>  ，这个呢，是一个大佬的晋升之路。至于自己能走到哪，看造化吧。  </p>
</blockquote>
<h2 id="2、LeetCode-算法刷题"><a href="#2、LeetCode-算法刷题" class="headerlink" title="2、LeetCode 算法刷题"></a>2、LeetCode 算法刷题</h2><p>比起C++呢，这个篇章没有那么多，那么杂。But,but,真的耗时间。算法嘛，相当于修炼内功了，打好扎实的基础还是很有好处滴</p>
<p><img src="https://pic.imgdb.cn/item/60978afdd1a9ae528f608a6e.png"></p>
<p>这本书呢，是一个Google大佬编的，对我呢还是挺友好的，现在看到了那个分治法。刷题也要先学基本功对不对，进力扣网站，刚开始就整一些动态规划啊，贪心算法巴拉巴拉的名词，一道题刷一天也不是办法对不对。</p>
<h2 id="3、Linux-Unix系统开发的学习"><a href="#3、Linux-Unix系统开发的学习" class="headerlink" title="3、Linux /Unix系统开发的学习"></a>3、Linux /Unix系统开发的学习</h2><p>因为呢，本身是走嵌入式开发学习方向的啊，Linux 的学习必不可少。之前几个学期呢，学了Shell 编程啊，进程开发，通信啊，文件IO什么的。又说呢，学习要细致，来，上干货啃书。</p>
<p><img src="https://pic.imgdb.cn/item/60978d33d1a9ae528f80c0aa.png"></p>
<p>嘶，，822页。但是呢，我之前五一啃完了一本Linux 系统编程。看着目录还行，内容上面都是老熟人了，得空就啃了。</p>
<h2 id="4、数据结构的学习"><a href="#4、数据结构的学习" class="headerlink" title="4、数据结构的学习"></a>4、数据结构的学习</h2><p>3月份呢，过了一遍数据结构的书，但是呢，现在基本忘光。二刷，不就树啊，图什么的。</p>
<h2 id="5、英语"><a href="#5、英语" class="headerlink" title="5、英语"></a>5、英语</h2><p>6月份考六级了，现在呢，单词准备过第二遍，刷十几套试卷什么的，这不，上午刚了<u>七十几个</u>单词 ，不是吹的，主要是第二遍，速度比较抓紧一点。刷试卷还是要刷滴，英语考试对我来说就是考题感，感觉刷上来了什么都好说。</p>
<p>完，暂时就这些，后期呢，准备搞一下网络，单片机，ARM开发的复习，还有搞一下QT的学习。下午的话搞一下这个博客的使用，再看一下科目四，星期二就要拿证了，芜湖~</p>
]]></content>
      <tags>
        <tag>学习之旅</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2021/05/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><span id="more"></span>

<p>在搜索到一个新的节点时，立即对该新节点进行遍历，需要依靠先入后出的栈来实现，也可以通过与栈等价的递归来实现。也可以用来检测环路。拓扑排序可以判断是否有环路。</p>
<h3 id="1、最大水洼求值"><a href="#1、最大水洼求值" class="headerlink" title="1、最大水洼求值"></a>1、最大水洼求值</h3><p>Input: [[1,0,1,1,0,1,0,1], </p>
<p>​           [1,0,1,1,0,1,1,1],</p>
<p>​           [0,0,0,0,0,0,0,1]]                    Output: 6</p>
<h4 id="递归思路："><a href="#递归思路：" class="headerlink" title="递归思路："></a>递归思路：</h4><p>​           (1)  分为主函数( 用于遍历判断” 1 “ 的位置，开始递归搜索 )和辅函数( 用于递归搜索”1”的位置)</p>
<p>​           (2) 辅函数中逢”1” 置 “0” ，临近水洼置”0” , 避免重复判断</p>
<p>​           (3)递归搜索时，边界(矩阵越界)判断方法两种：先判断是否越界再开始搜索（即判断放在调用 递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合 法（即判断放在辅函数第一行）。</p>
<p>第一种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//判断上下左右的位置</span></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;   <span class="comment">//遍历二维数组得到陷入递归函数的调用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;   <span class="comment">//判断水洼陷入递归函数调用</span></span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));  <span class="comment">//比较函数，得到最大数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y, area = <span class="number">1</span>;   <span class="comment">//每一次递归(取到一个&quot;1&quot;)都会return 一个area,最后累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];   <span class="comment">//取四个方向的递归</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);   <span class="comment">//累计水洼数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() ||c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的写法："><a href="#栈的写法：" class="headerlink" title="栈的写法："></a>栈的写法：</h4><p>关于图片加载的问题：上传到github ,下一篇开始采用聚合图床上传</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B0%B4%E6%B4%BC.png" alt="水洼"></p>
<p>思路：针对每一个入栈的元素 [r , c] 都进行4次的坐标入栈。 local_area 的累加都在判断中间。max 的 取值都在主循环</p>
<h3 id="2、海流方向"><a href="#2、海流方向" class="headerlink" title="2、海流方向"></a>2、海流方向</h3><p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B5%B7%E6%B5%81%E6%96%B9%E5%90%91.png"></p>
<p>思路：因此我们可以反过来想，从两个大洋开始向上流，这样我们 只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋 向上流都能到达的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到太平洋</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到大西洋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);    <span class="comment">//左边开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);  <span class="comment">//从右边开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);    <span class="comment">//从上面开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);   <span class="comment">//从下面开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);      <span class="comment">//两大洋都能流到，压栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; can_reach,<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;   <span class="comment">//满足条件(找到最高点即退出循环，可以先置&quot;true&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>()</span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            matrix[r][c] &lt;= matrix[x][y]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);  <span class="comment">//判断条件为：边界判断以及最高点条件判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><blockquote>
<p>[修改当前节点状态]→[递归子节点]→[回改当前节点 状态]。         此路不通，修改之前一步的状态，回退一步，继续搜索。</p>
</blockquote>
<h3 id="1、全排列"><a href="#1、全排列" class="headerlink" title="1、全排列"></a>1、全排列</h3><p>[1,2,3]  的可能排列方式 ，题解可以采用树形结构：</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E5%85%A8%E6%8E%92%E5%88%97.png" alt="全排列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>1、level 为树的层次，递归的终止条件为：level == nums.size() -1,到树底部终结递归</p>
<p>2、for循环中的 level 和 level+1 ，每次递归都会随着树的深度增加而发生变化，但是始终没有改变值。(栈空间的临时存储)。</p>
<p>3、过程模拟:  第一棵树： i = 0,level=0 , 即[1,2,3],进行交换。子树里面,level增加，i又要从level到nums.size()-1来分配情况。第一个确定，依据 level 来交换情况</p>
<p>4、i+1 的时候要回退一步(回到根节点来进行回溯)。在修改结点，递归后面回退根节点的状态，即swap(nums[i],nums[level]);</p>
<h3 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h3><p>Input: n = 4, k = 2 </p>
<p>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;  <span class="comment">//最后输出数据</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);  <span class="comment">//count 计算深度,comb临时两个[a,b]数组，&quot;1&quot;为初始位置开始也可看做深度</span></span><br><span class="line">    <span class="comment">//count作为数组的编号取值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; comb, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  pos, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; ++i) &#123;</span><br><span class="line">        comb[count++] = i; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k); <span class="comment">// 递归子节点</span></span><br><span class="line">        --count; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E7%BB%84%E5%90%88.png"></p>
<h3 id="3、字符串搜索"><a href="#3、字符串搜索" class="headerlink" title="3、字符串搜索"></a>3、字符串搜索</h3><p>Input: word = “ABCCED”, board = [[’A’,’B’,’C’,’E’],</p>
<p>​                                                        [’S’,’F’,’C’,’S’], </p>
<p>​                                                        [’A’,’D’,’E’,’E’]] </p>
<p>Output: true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="keyword">bool</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  &amp; find, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">    <span class="comment">// 递归子节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>广度优先搜索(BFS)采用先进先出的队列结构，深度优先采用先进后出的栈结构</p>
<h3 id="1、两个岛屿最小距离"><a href="#1、两个岛屿最小距离" class="headerlink" title="1、两个岛屿最小距离"></a>1、两个岛屿最小距离</h3><p>(深度优先查找一个岛屿的位置，全部置为”2” , 接着从岛屿的各个周围遍历，直到找到另一个岛屿，即是最短距离)</p>
<p>Input: </p>
<p>​          [[1,1,1,1,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,0,1,0,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,1,1,1,1]] </p>
<p>Output: 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="comment">// dfs寻找第一个岛屿，并把1全部赋值为2</span></span><br><span class="line">    <span class="keyword">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs寻找第二个岛屿，并把过程中经过的0赋值为2</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();   <span class="comment">//n个临近海域搜索，完结后进入第二级海域</span></span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n</span></span></span><br><span class="line"><span class="function"><span class="params">         , <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--points队列里面存的是临近第一个小岛的海域-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(2)</title>
    <url>/2021/07/02/%E5%81%87%E6%9C%9F(2)/</url>
    <content><![CDATA[<h2 id="Second-–-02（栈）"><a href="#Second-–-02（栈）" class="headerlink" title="Second – 02（栈）"></a>Second – 02（栈）</h2><p>9.24  AM</p>
<span id="more"></span>

<h2 id="一、小题"><a href="#一、小题" class="headerlink" title="一、小题"></a>一、小题</h2><h3 id="（1）删除结点问题"><a href="#（1）删除结点问题" class="headerlink" title="（1）删除结点问题"></a>（1）删除结点问题</h3><p><img src="https://pic.imgdb.cn/item/60de6b3e5132923bf85b2a6e.png"></p>
<h3 id="2-单链表：写一个函数合并两个升序单链表"><a href="#2-单链表：写一个函数合并两个升序单链表" class="headerlink" title="(2)单链表：写一个函数合并两个升序单链表"></a>(2)单链表：写一个函数合并两个升序单链表</h3><p>要求：不能额外申请空间，合并的链表仍然有序</p>
<p>两种方法:  一种直接一个一个插入</p>
<p>二种:两两pk，谁小往后面挪 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Merge</span><span class="params">(Node* ha, Node* hb)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法一:</span></span><br><span class="line"><span class="comment">      把ha的结点一个一个摘下来，然后按“插入排序”</span></span><br><span class="line"><span class="comment">      插入到hb的链表中去。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法二:</span></span><br><span class="line"><span class="comment">      “两两PK,谁小谁往后挪，挪之前先链接起来”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      ph 指向合并后的链表的第一个结点</span></span><br><span class="line"><span class="comment">      pt 指向合并后的链表的最后一个结点*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = ha;</span><br><span class="line">          ha = ha-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = hb;</span><br><span class="line">          hb = hb-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (ha &amp;&amp; hb)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = ha;</span><br><span class="line">              pt = ha;</span><br><span class="line">              ha = ha-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = hb;</span><br><span class="line">              pt = hb;</span><br><span class="line">              hb = hb-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ha)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = ha;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hb)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = hb;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ph;</span><br></pre></td></tr></table></figure>

<h3 id="3-对一个单链表进行排序"><a href="#3-对一个单链表进行排序" class="headerlink" title="(3)对一个单链表进行排序"></a>(3)对一个单链表进行排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node*  <span class="title">Sort_Bubble</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span> || h-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *pk = h;  </span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向pk前面的那个结点 </span></span><br><span class="line">    Node *pn = (pk == <span class="literal">NULL</span>) ? <span class="literal">NULL</span>: pk-&gt;next; </span><br><span class="line">        <span class="comment">//pn指向pk后面的那个结点</span></span><br><span class="line"></span><br><span class="line">    Node *ps = <span class="literal">NULL</span>;<span class="comment">//指向后面的那个有序表的第一个结点</span></span><br><span class="line">    Node *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h != ps)  <span class="comment">//已排序后的部分逼到头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pk = h;</span><br><span class="line">        pn = pk-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pn != ps)  <span class="comment">//pn后面跟着的是已排好的部分</span></span><br><span class="line">        &#123;</span><br><span class="line">		   <span class="keyword">if</span> (pk-&gt;data &lt;= pn-&gt;data)  <span class="comment">//如果有序的话，直接移位</span></span><br><span class="line">            &#123;</span><br><span class="line">                pr = pk;</span><br><span class="line">                pk = pn;</span><br><span class="line">                pn = pn-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>   <span class="comment">//开始交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = pn-&gt;next;</span><br><span class="line">                pn-&gt;next = pk;</span><br><span class="line">                pk-&gt;next = r;</span><br><span class="line">                <span class="keyword">if</span> (pr)</span><br><span class="line">                &#123;</span><br><span class="line">                    pr-&gt;next = pn;</span><br><span class="line">                &#125;</span><br><span class="line">                pr = pn;</span><br><span class="line">                pn = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ps = pk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><p><img src="https://pic.imgdb.cn/item/60debb855132923bf8261c96.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfc8735132923bf8964303.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfcb965132923bf8ac9a02.png"></p>
<p>​                                                            //  fgets函数的应用  ，其不能识别换行符(回车键),所以进行代替操作   </p>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>栈顶和栈底倒转，头部删除（不需要引入另一个指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="comment">//&quot;数据结点&quot;存放栈元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SELemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;SNode;</span><br><span class="line"></span><br><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SNode *Bottom; <span class="comment">//指向栈底元素</span></span><br><span class="line">    SNode *Top;  <span class="comment">//指向栈顶的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//链式栈的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>链式栈的清空和销毁：清空表示干掉所有数据结点</p>
<p>销毁表示还要干掉头结点</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队尾(rear):允许插入元素的一端</p>
<p>队头(front):允许删除元素的一端</p>
<p>实现：顺序结构和链式结构，操作：InitQueue  DestroyQueue ClearQueue   QueueIsEmpty  QueueLength</p>
<p>“排队论”</p>
<h3 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="(1)顺序队列"></a>(1)顺序队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现理念：数组，队尾，队首指针，数组的最大长度。</span></span><br><span class="line"><span class="comment">  入队从队尾入，出队从队首出。队尾队首的表示方法都是下标表示</span></span><br><span class="line"><span class="comment">  能够实现空间循环使用的效果：出队或者入队。如果队尾/队首指针达到最大长度时，自动转到下标为零(数组空间开头)</span></span><br><span class="line"><span class="comment">  实现空间的循环利用。实现队列存储操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）链式队列"><a href="#（2）链式队列" class="headerlink" title="（2）链式队列"></a>（2）链式队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据结点类型描述：数据域，前指针和后指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存队元素的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NOde</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *Front; <span class="comment">//指向队头结点</span></span><br><span class="line">    Node *Rear;  <span class="comment">//指向队尾结点</span></span><br><span class="line">    <span class="keyword">int</span> Length;  <span class="comment">//队列中元素的个数</span></span><br><span class="line">&#125;LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列类型头指针:队首元素的指针 队尾元素的指针 队列元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）不采用长度标志位-availuble-标志长度"><a href="#（3）不采用长度标志位-availuble-标志长度" class="headerlink" title="（3）不采用长度标志位   availuble 标志长度"></a>（3）不采用长度标志位   availuble 标志长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//牺牲一个空间，rear 指向最后一个空位表示满</span></span><br><span class="line">(rear + <span class="number">1</span>) % capacity == front  <span class="comment">//队列满</span></span><br><span class="line">front == rear    <span class="comment">//队列为空</span></span><br><span class="line">(rear-front+capacity)%capacity   <span class="comment">//计算元素个数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事</title>
    <url>/2021/05/11/%E6%97%A5%E5%B8%B8%E4%BA%8B/</url>
    <content><![CDATA[<p>冲浪发现的博客</p>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/609a400dd1a9ae528f35806c.png"></p>
<blockquote>
<p><a href="https://wujun234.github.io/">https://wujun234.github.io/</a></p>
</blockquote>
<p>有时候找些想要学的途径，杂七杂八的不好下手，非常好的知识梳理框架，康康大佬是怎么学习的</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客</title>
    <url>/2021/05/30/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>博客的更新是很有必要的，有两个博客。</p>
<span id="more"></span>

<p>本博客基于 hexo 主题和 github静态页面，非技术流，风格较偏向于流水账 &gt;__&lt; ,。入坑教程:<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a>  </p>
<p>另一个博客基于腾讯云的轻量服务器的wordpress应用，为动态博客。域名还未申请。</p>
<p>7.15</p>
<p>域名的备案也太麻烦了吧。。。。有时间再弄</p>
<iframe src="//player.bilibili.com/player.html?aid=69636686&bvid=BV1LE41197WA&cid=136391011&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程(1)</title>
    <url>/2021/08/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/</url>
    <content><![CDATA[<h1 id="网络编程（1）"><a href="#网络编程（1）" class="headerlink" title="网络编程（1）"></a>网络编程（1）</h1><span id="more"></span>

<blockquote>
<p>碎碎念：封面桌面新添加程序 Rainmeter (桌面美化组件) ，时钟，频谱  <a href="https://www.bilibili.com/video/BV1N5411x7KP">雨滴桌面教程|深度打造你的自定义桌面（Rainmeter教程）_哔哩哔哩_bilibili</a>  ，关于雨滴桌面相关的网站有：致美化 ，雨滴社区  待完善：Dock 快捷方式的设置</p>
</blockquote>
<h2 id="一、Unix-域协议"><a href="#一、Unix-域协议" class="headerlink" title="一、Unix 域协议"></a>一、Unix 域协议</h2><p>同一主机的两个进程之间的通信（Socket 本地通信）,不是所有的主机都装有TCP/IP协议栈，所以不是系统都有IP地址，当然linux 都有移植</p>
<blockquote>
<p>原理：一个进程利用Socket接口数据写到内核，另一个利用接口数据读取到自己的进程空间，(全双工通信)</p>
</blockquote>
<p>Socket 接口文件名随文件系统持续性，而内容随内核持续性  为了实现全双工，应用层设置通信规则，设置相关的读写文件</p>
<p><img src="https://pic.imgdb.cn/item/611a592f5132923bf89a9c34.png"></p>
<p>​                                                                                    （域协议）</p>
<p><em>域协议的套接字类型也可以是UDP或者是TCP</em>  实际中选择UDP数据报套接字  效率高，出错率低</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>(1)每进程都分配一个域协议套接字，两者都应该进行网络地址(文件路径)的绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	create_unix_socket:创建一个本进程的</span></span><br><span class="line"><span class="comment">			unix域协议的套接字(udp)</span></span><br><span class="line"><span class="comment">	@path: unix域协议的本地绝对路径</span></span><br><span class="line"><span class="comment">	返回值:</span></span><br><span class="line"><span class="comment">		成功返回 Unix域协议套接字描述符</span></span><br><span class="line"><span class="comment">		失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_unix_socket</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 创建一个socket</span></span><br><span class="line">	sock = socket(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;create_unix_socket socket error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2. 绑定一个unix域协议的地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">lo</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//协议族设置为unix 域协议</span></span><br><span class="line">	lo.sun_family = AF_UNIX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址是一个本地字符串 (sun_path)  如: &quot;./read.socket&quot;</span></span><br><span class="line">	<span class="built_in">strncpy</span>(lo.sun_path, path,  <span class="keyword">sizeof</span>(lo.sun_path));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//绑定套接字和网络地址</span></span><br><span class="line">    ret = bind(sock, (struct sockaddr*)&amp;lo, <span class="keyword">sizeof</span>(lo));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;create_unix_socket bind error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>void unlink_unix_localpath(char *path) &#123;unlink(path);&#125;</code>   //ulink 函数解除一个链接，即删除一个文件</p>
<p>（2）向目标发送数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	send_unix_data:通过unix域协议套接字，发送数据给指定的接收方</span></span><br><span class="line"><span class="comment">	@sock:Unix域协议套接字</span></span><br><span class="line"><span class="comment">	@DestPath: 接收方的Unix域协议地址</span></span><br><span class="line"><span class="comment">	@data: 指向要发送的数据的首地址</span></span><br><span class="line"><span class="comment">	@len: 要发送多少字节的数据</span></span><br><span class="line"><span class="comment">	返回值:</span></span><br><span class="line"><span class="comment">		成功，返回实际发送的数据的字节数</span></span><br><span class="line"><span class="comment">		失败，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_unix_data</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *DestPath, <span class="keyword">char</span> *data, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//目标创建一个网络地址，方便发送</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">re</span>;</span></span><br><span class="line">	re.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strncpy</span>(re.sun_path, DestPath, <span class="keyword">sizeof</span>(re.sun_path));</span><br><span class="line"></span><br><span class="line">	ret = sendto(sock, data, len, <span class="number">0</span>, (struct sockaddr*)&amp;re, <span class="keyword">sizeof</span>(re));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;send_unix_data sendto error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）接收数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	recv_unix_data:通过unix域协议套接字，接收数据</span></span><br><span class="line"><span class="comment">	@sock:unix域协议套接字</span></span><br><span class="line"><span class="comment">	@buf: 指针，指向的空间，用来保存接收到的数据</span></span><br><span class="line"><span class="comment">	@max_len: buf指向的空间的最大的长度</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		成功，返回实际接收到的数据的字节数</span></span><br><span class="line"><span class="comment">		失败，返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_unix_data</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = recvfrom(sock, buf, max_len, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;recv_unix_data recvfrom error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，sock 参数为进程自己的sock </p>
</blockquote>
<p>（4）测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = create_unix_socket(<span class="string">&quot;./send.socket&quot;</span>);</span><br><span class="line">    send_unix_data(sock,<span class="string">&quot;./rec.socket&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    unlink(<span class="string">&quot;./send.socket&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> sock = create_unix_socket(<span class="string">&quot;./rec.socket&quot;</span>);</span><br><span class="line">    recv_unix_data(sock, buf, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    unlink(<span class="string">&quot;./rec.socket&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//运行过程中，如果发送端没有找到接收端的套接字文件，则发生错误  （连接拒绝）</p>
<h2 id="二、广播通信"><a href="#二、广播通信" class="headerlink" title="二、广播通信"></a>二、广播通信</h2><p><img src="https://pic.imgdb.cn/item/611a650f5132923bf8d197b5.png"></p>
<p>​                                                                                    底层通信基础（j具有接收，发送缓冲区）</p>
<p>cd /proc/   打开进程文件    ps -ef   显示进程详细信息  </p>
<p>思考：在进程文件夹里面建立套接字文件   缺点：进程结束后，路径消失，但是文件结点没有消失，容易造成内存泄漏</p>
<h3 id="（1）套接字的选项问题"><a href="#（1）套接字的选项问题" class="headerlink" title="（1）套接字的选项问题"></a>（1）套接字的选项问题</h3><p>引入问题：绑定失败的情况 </p>
<p>每个套接字在不同的协议层上都有不同的行为属性，称之为套接字的”选项 “      在内核中有相关的两个函数  setsockopt ：设置  getsockopt:获取</p>
<p><img src="https://pic.imgdb.cn/item/611a68d35132923bf8e51610.png"></p>
<p>举另一个栗子:  获取缓冲区(发送，接收)大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取缓冲区大小</span></span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">int</span> sockfd2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s_size,s_len;</span><br><span class="line">    s_len=<span class="keyword">sizeof</span>(s_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r_size,r_len;</span><br><span class="line">    r_len=<span class="keyword">sizeof</span>(r_size);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    sockfd2 = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    getsockopt(sockfd,SOL_SOCKET,SO_SNDBUF,&amp;s_size,&amp;s_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tcp 套接字发送缓冲区大小: %d \n&quot;</span>,s_size);</span><br><span class="line"></span><br><span class="line">    getsockopt(sockfd,SOL_SOCKET,SO_RCVBUF,&amp;s_size,&amp;s_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tcp 套接字接收缓冲区大小: %d \n&quot;</span>,s_size);</span><br><span class="line"></span><br><span class="line">    getsockopt(sockfd2,SOL_SOCKET,SO_SNDBUF,&amp;s_size,&amp;s_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp 套接字发送缓冲区大小: %d \n&quot;</span>,s_size);</span><br><span class="line"></span><br><span class="line">    getsockopt(sockfd2,SOL_SOCKET,SO_RCVBUF,&amp;s_size,&amp;s_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp 套接字接收缓冲区大小: %d \n&quot;</span>,s_size);</span><br></pre></td></tr></table></figure>

<h3 id="2-广播通信"><a href="#2-广播通信" class="headerlink" title="(2)广播通信"></a>(2)广播通信</h3><p>指定子网内的广播地址 （主机号全部为1）的那个地址就是广播地址</p>
<p><img src="https://pic.imgdb.cn/item/611a6aa95132923bf8eebf12.png"></p>
<p>广播流程</p>
<p><img src="https://pic.imgdb.cn/item/611a6b485132923bf8f1f02b.png"></p>
<p>程序：</p>
<p>发送者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>			<span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_broadcast_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.创建一个socket</span></span><br><span class="line">	<span class="keyword">int</span> sock = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 使能广播功能</span></span><br><span class="line">	<span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, </span><br><span class="line">					(<span class="keyword">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;setsockopt error&quot;</span>);</span><br><span class="line"></span><br><span class="line">		close(sock);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_broadcast_data</span><span class="params">(<span class="keyword">int</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">char</span> *broadcast_ip, <span class="keyword">short</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">char</span> *data, <span class="keyword">int</span> len</span></span></span><br><span class="line"><span class="function"><span class="params">						)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">broadcast_addr</span>;</span></span><br><span class="line">	broadcast_addr.sin_family = AF_INET;</span><br><span class="line">	broadcast_addr.sin_port = htons(port);</span><br><span class="line">	broadcast_addr.sin_addr.s_addr = inet_addr(broadcast_ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = sendto(sock, data, len, <span class="number">0</span>,</span><br><span class="line">				(struct sockaddr*)&amp;broadcast_addr, <span class="keyword">sizeof</span>(broadcast_addr));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcast_send port broadcast_ip</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock = create_broadcast_socket();</span><br><span class="line">	<span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;failed to create_broadcast_socket\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> second = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		second++;</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">		<span class="keyword">int</span> r = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%ld&quot;</span>, second);</span><br><span class="line">		<span class="keyword">int</span> ret = send_broadcast_data(sock, argv[<span class="number">2</span>], atoi(argv[<span class="number">1</span>]), </span><br><span class="line">				buf, r + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接收者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>			<span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_broadcast_recv_socket</span><span class="params">(<span class="keyword">short</span> port, <span class="keyword">char</span> *baddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.创建一个socket</span></span><br><span class="line">	<span class="keyword">int</span> sock = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 使能广播功能</span></span><br><span class="line">	<span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, </span><br><span class="line">					(<span class="keyword">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//地址和端口复用</span></span><br><span class="line">	ret = setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">	ret = setsockopt(sock,SOL_SOCKET,SO_REUSEPORT,(<span class="keyword">void</span>*)&amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;setsockopt error&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> create_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">broadcast_addr</span>;</span></span><br><span class="line">	broadcast_addr.sin_family = AF_INET;</span><br><span class="line">	broadcast_addr.sin_port = htons(port);</span><br><span class="line">	broadcast_addr.sin_addr.s_addr = inet_addr(baddr);</span><br><span class="line"></span><br><span class="line">	ret = bind(sock, (struct sockaddr*)&amp;broadcast_addr, <span class="keyword">sizeof</span>(broadcast_addr));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> create_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line"></span><br><span class="line">create_err:</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事-实训(智能家居系统)</title>
    <url>/2021/06/16/%E6%97%A5%E5%B8%B8%E4%BA%8B-2/</url>
    <content><![CDATA[<p>为期三周的实训告一段落。</p>
<span id="more"></span>

<h1 id="完成智能家居系统"><a href="#完成智能家居系统" class="headerlink" title="完成智能家居系统"></a>完成智能家居系统</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>学习Zigbee 无线局域网 的组网技术。 </p>
<p>开发工具包：Ztack 协议栈  软件：一个下载软件 ，一个编译软件。 以.hex文件烧录到Zigbee模块。外设有：LED灯，温度，湿度检测，按键。</p>
<p>成品:1.一个模块作为适配器，适配器是局域网组网的原点。2、共有三种模式：适配器模式，路由器模式和终端模式  3、适配器和终端组网通信，通过串口打印信息。</p>
<h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p>学习C++基础知识。新知识点：构造函数的知识，编译器优化和不优化的区别以及指令。《Prime C++》看完，内容多而杂。后期提升多敲代码。对C++颇感兴趣</p>
<h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p>学习QT的知识。</p>
<p>重中之重。。看完B站上的QT教程 <a href="https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14">https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14</a> </p>
<p>如今，着重运用的技术有：信号和槽、各种组件类的运用，QT提供的服务(主要存放在.obj文件上)。-&gt;QT程序在Linux环境上的交叉编译，生成可执行文件。传输到GEC6818开发板上运行程序。</p>
<p>总结:QT的基本概念清晰。但是，软肋就是不会折腾。室友夜以继日的卷，明显自己的基本了解完全不行&gt;__&lt; 。 外加美术功底的问题，界面设计实在不太理想。。</p>
<h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>多多更新博客，多多上传项目到github，多多折腾</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法2</title>
    <url>/2021/07/09/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<h2 id="一、有关图的深度优先搜索和广度优先搜索"><a href="#一、有关图的深度优先搜索和广度优先搜索" class="headerlink" title="一、有关图的深度优先搜索和广度优先搜索"></a>一、有关图的深度优先搜索和广度优先搜索</h2><span id="more"></span>

<h3 id="1、图的表达方式以及图的建立"><a href="#1、图的表达方式以及图的建立" class="headerlink" title="1、图的表达方式以及图的建立"></a>1、图的表达方式以及图的建立</h3><p>邻接矩阵的表示方法：设置顶点数组和邻接矩阵二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN      100   <span class="comment">//图中顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERY_BIG  65535    <span class="comment">//无穷大</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VType V[MAXN] ; <span class="comment">//一维数组用来存储顶点的数据</span></span><br><span class="line"></span><br><span class="line">    WType A[MAXN][MAXN] ; <span class="comment">//存储边上的权w,&quot;邻接矩阵&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> VexNum;<span class="comment">//图中实际顶点的个数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​                                                                            <img src="https://pic.imgdb.cn/item/60e803285132923bf8386a12.png"></p>
<p>例如：数字表示边的权值横向表示起始点方向，没有边的情况表示无穷大，在代码中，无穷大为65535</p>
<p>图的建立过程：先输入顶点集例如：ABCDEFG   然后输入边格式:AB8 (起点 终点 权值) ,当起点输入为’#’ 时退出循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g-&gt;V); <span class="comment">//输入顶点集</span></span><br><span class="line">getchar();     <span class="comment">//清空输入缓冲区</span></span><br><span class="line">g-&gt;VexNum = <span class="built_in">strlen</span>(g-&gt;V);   <span class="comment">//获取顶点数组的有效长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>()</span><br><span class="line">&#123;</span><br><span class="line">           <span class="comment">//邻接二维矩阵初始化为无穷大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> Start;</span><br><span class="line">    <span class="keyword">char</span> Stop;</span><br><span class="line">    <span class="keyword">int</span> w;  <span class="comment">//权值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c%c%d&quot;</span>,&amp;Start,&amp;Stop,&amp;w);   <span class="comment">//输入格式</span></span><br><span class="line">    <span class="keyword">int</span> Startindex = getindex(V,g-&gt;VexNum,Start);  <span class="comment">//输入的字符返回下标</span></span><br><span class="line">    <span class="keyword">int</span> Stopindex = getindex(V,g-&gt;VexNum,STop);    <span class="comment">//输入的字符返回下标</span></span><br><span class="line">    g-&gt;A[Startindex][Stopindex] = w;   <span class="comment">//赋值二维数组以权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、图的深度优先遍历"><a href="#2、图的深度优先遍历" class="headerlink" title="2、图的深度优先遍历"></a>2、图的深度优先遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找第v0 行从pos开始的 有效 结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNextLJD</span><span class="params">(Graph*g , <span class="keyword">int</span> v0, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = pos; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;A[v0][i] != VERY_BIG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//从图中下标为v0的那个顶点出发，按照DFS(深度优先)的去访问它能够访问的</span></span><br><span class="line"><span class="comment">//所有邻接点。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph* g,  <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//(1)访问v0,并标记</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c--&quot;</span>, g-&gt;V[v0]);</span><br><span class="line">    visited[v0] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">int</span> vi; <span class="comment">//表示 v0的下一个邻接点</span></span><br><span class="line">    <span class="keyword">for</span> (vi = FindNextLJD(g,v0,<span class="number">0</span>); vi != <span class="number">-1</span> ;   vi = FindNextLJD(g,v0, vi+<span class="number">1</span>))  </span><br><span class="line">    <span class="comment">//第一次循环的时候从0开始，下一次从vi的下一个开始查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[vi] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(g, vi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了适配非连通的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraver</span><span class="params">(Graph *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先初始化的辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g-&gt;VexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(g, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、图的广度优先遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph* g,  <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Queue[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Queue[rear++] = v0;  <span class="comment">//第一个结点入队</span></span><br><span class="line">    <span class="keyword">if</span>(rear == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rear != front)  <span class="comment">//如果队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vi;</span><br><span class="line">        visited2[Queue[front]] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下一个邻接点入队</span></span><br><span class="line">        <span class="keyword">for</span> (vi = FindNextLJD(g,Queue[front],<span class="number">0</span>); vi != <span class="number">-1</span> ; vi = FindNextLJD(g,Queue[front], vi+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited2[vi] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[rear++] = vi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,g-&gt;V[Queue[front++]]);  <span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rear == <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>标准IO和系统IO</title>
    <url>/2021/07/21/%E6%A0%87%E5%87%86IO%E5%92%8C%E7%B3%BB%E7%BB%9FIO/</url>
    <content><![CDATA[<h1 id="系统IO和文件IO那些事"><a href="#系统IO和文件IO那些事" class="headerlink" title="系统IO和文件IO那些事"></a>系统IO和文件IO那些事</h1><span id="more"></span>

<blockquote>
<p><em>碎碎念</em>：(文章封面)安装好了Kali Linux,虽然不知道怎么用</p>
</blockquote>
<h1 id="1-为什么需要标准IO？"><a href="#1-为什么需要标准IO？" class="headerlink" title="1. 为什么需要标准IO？"></a>1. 为什么需要标准IO？</h1><pre><code>you know, 每个操作系统下面，对文件的管理和接口不一样！！
    Linux: open/read/write/lseek/close ..., struct file, struct inode
    Windows: WinOpen?/WinClose?/。。。

=&gt;
    同一个文件，并且同样是用C语言去操作，在不同的操作系统下面， 
    操作文件的代码是不一样的。

C语言标准委员会，他觉得他有必须站出来，他有责任、有义务、有能力一统江湖，千秋万代。
统一文件操作的接口。如何去统一呢?
    C语言标准委员会搞了一个 标准IO库：主要统一对文件及常用接口的操作。
“文件”： 普通文本文件和二进制文件
    文本文件： 无组织、无格式的文件，以字符的ASCII码来解析文件。
        如:
            .txt  .c .h .s .asm .cpp .java ...
        打开这类文件(&quot;文本文件&quot;)，只需要普通文本编辑器(如: vim, 记事本，
        source insight, nodepad++, vscode ....)。
    二进制文件：有特定格式的文件
        如:
            .jpg .bmp .gif ..
                特定的图片浏览的程序去打开
            .doc .xls
            a.out
            ...
</code></pre>
<h1 id="2-标准IO库及实现"><a href="#2-标准IO库及实现" class="headerlink" title="2. 标准IO库及实现"></a>2. 标准IO库及实现</h1><pre><code>C语言标准委员会，为了统一文件操作的接口而弄的一套C语言写的操作文件
的应用程序的库。 这个库在几乎所有支持C语言的操作系统中都可以用。

在标准IO库中， 用结构体  FILE 来描述一个文件，然后在这个结构体中
创建两个缓冲区(一段内存)：
    一个读缓冲区
    一个写缓冲区

FILE
&#123;
    char *in;   //指向读的缓冲区
    char *out; //指向写的缓冲区
    ...
&#125;;

还提供了对“文件”操作的接口函数:
    fopen/fclose/fread/fwrite/fseek/...
    puts/gets/fputs/fgets/scanf/printf...

Your code &lt;--&gt; 标准IO库(如:fopen...) &lt;----&gt; 系统IO ----&gt;内核 -----&gt; Hardware

FILE有两个缓冲区(标准IO库会为每个打开的文件开辟一段内存)
    *in  ---&gt; 读的缓冲区
    *out ---&gt; 写的缓冲区
标准IO，又叫带缓冲的IO, 又叫IO流，它的效率要比系统IO要高，why?
    系统IO:
        读 1byte 从硬盘中读一个字节出来
    标准IO:
        读 1byte 从硬盘中读一块(如:512bytes)出来，放到标准IO的读缓冲区

缓冲： 同步问题
    缓冲区中的数据，何时同步到外设上去呢？
    缓冲区开多大呢？ ...
标准IO库缓冲区有三种类型:
    行缓冲：缓冲区数据达到一行或遇到\n，才同步到外设中去。  
            假设您设置一行顶多80bytes
            遇到\n(换行符，一行结束的标志)
            字节数达到80了，或者遇到\n，就会把缓冲区的数据同步到外设上去。 

            printf --&gt;行缓冲
            main()
            &#123;
                printf(&quot;就是不听你的&quot;);
                while (1);
            &#125;

    全缓冲:
        缓冲区中数据要填满整个缓冲区，才同步到外设上去。

    无缓冲：
        缓冲中有一个字节，就同步到外设上去。
        perror -&gt; 无缓冲

标准IO库，会自动为每个进程，打开三个标准IO流(文件):
    标准输入流： FILE* stdin
        stdin定义在stdio.h中的一个全局变量，它指向
        标准输入设备(一般为键盘或终端)
        
        scanf(&quot;%d&quot;, &amp;i); &lt;-- stdin

    标准输出流: FILE* stdout
        stdout定义在stdio.h中的一个全局变量，它指向
        标准输出设备(控制台console,终端或屏幕)

        printf(&quot;&quot;); ---&gt; stdout

    标准出错流: FILE* stderr
        stderr定义在stdio.h中的一个全局变量，它指向
        标准出错设备(一般为终端)

        perror() --&gt; stderr
</code></pre>
<h1 id="3-标准IO的函数接口"><a href="#3-标准IO的函数接口" class="headerlink" title="3.标准IO的函数接口"></a>3.标准IO的函数接口</h1><h2 id="3-1-打开或关闭一个文件流"><a href="#3-1-打开或关闭一个文件流" class="headerlink" title="3.1 打开或关闭一个文件流"></a>3.1 打开或关闭一个文件流</h2><pre><code>fopen/fdopen
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">        pathname:要打开的那个文件的文件名，“字符串”</span><br><span class="line">        mode: 打开文件的方式，有如下几种:</span><br><span class="line">            <span class="string">&quot;r&quot;</span> : 只读打开。文件不存在，则报错</span><br><span class="line">                打开后，光标在开头</span><br><span class="line">            <span class="string">&quot;r+&quot;</span>: 读写打开。文件不存在，则报错。</span><br><span class="line">                打开后，光标在开头</span><br><span class="line">            <span class="string">&quot;w&quot;</span>: 只写打开。文件不存在，则创建。</span><br><span class="line">                打开后，文件内容截短(文件内容被清掉)</span><br><span class="line">            <span class="string">&quot;w+&quot;</span>:读写打开。文件不存在，则创建。</span><br><span class="line">                打开后，文件内容截短(文件内容被清掉)</span><br><span class="line">            <span class="string">&quot;a&quot;</span>: append 追加打开。文件不存在，则创建。</span><br><span class="line">                打开后，光标在末尾。文件内容不会被截短。</span><br><span class="line">            <span class="string">&quot;a+&quot;</span>: 读写打开。文件不存在，则创建。</span><br><span class="line">                原始读的位置在开头，原始写的位置在末尾。</span><br><span class="line">                文件内容不会被截短。</span><br><span class="line">        返回值：</span><br><span class="line">            成功返回标准IO库的文件指针，FILE*</span><br><span class="line">                在标准IO库中， FILE* 代表一个打开的文件，</span><br><span class="line">                后续标准IO库的函数都需要用到它。</span><br><span class="line">            失败返回<span class="literal">NULL</span>,同时errno被设置。</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">        fdopen同fopen类似，只是第一个参数是文件描述符fd</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    fclose - close a stream</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">        stream:FILE*,指定要关闭的文件流。</span><br><span class="line">        返回值:</span><br><span class="line">            成功返回<span class="number">0</span></span><br><span class="line">            失败返回<span class="number">-1</span>,同时errno被设置。</span><br></pre></td></tr></table></figure>

<h2 id="3-2-读写流"><a href="#3-2-读写流" class="headerlink" title="3.2 读写流"></a>3.2 读写流</h2><pre><code>一旦读写成功，光标会自动往后移n个位置(n就是您读取或写成功的字节数)
* 每次一个字符读写
* 每次一行读写
* 直接读写，您想要读写多少个对象都可以，看您方便
</code></pre>
<hr>
<pre><code>(1)每次一个字符地读写
fgetc/getc/getchar ----&gt;从文件流中读取一个字符
fputc/putc/putchar ----&gt;往文件流中写一个字符
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    fgetc用来从stream指定的文件流中，读取下一个字符</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">    stream:FILE*,指定要从哪个文件流读取字符</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回读到的那个字符的ASCII码(&gt;=<span class="number">0</span>)</span><br><span class="line">        失败返回<span class="number">-1</span>, 同时errno被设置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">    getc和fgetc是一样，也是用来从stream指定的文件流中，读取</span><br><span class="line">    下一个字符。getc和fgetc的区别在哪里呢?</span><br><span class="line">        fgetc是一个函数。</span><br><span class="line">        getc可能是用宏来实现。不需要函数调用的开销啦</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    getchar用来从标准输入流(<span class="built_in">stdin</span>)获取下一个字符，并把</span><br><span class="line">    读取到的字符的ASCII码返回.</span><br><span class="line">        getchar() &lt;=&gt; fgetc(<span class="built_in">stdin</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">   fputc用把字符c,写入到stream指定的文件流中去</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line">   c:要写入的字符的ASCII码</span><br><span class="line">   stream: FILE*,指定要写入的那个文件的文件指针</span><br><span class="line">   返回值：</span><br><span class="line">       成功，返回实际写入到文件流中的字符的ASCII码</span><br><span class="line">       失败，返回<span class="number">-1</span> 同时errno被设置</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line">   putc和fputc是一样的。</span><br><span class="line"></span><br><span class="line">   <span class="built_in">putchar</span>用来把c输出到 标准输出流(<span class="built_in">stdout</span>) 中去</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line">   <span class="built_in">putchar</span>(c) &lt;=&gt; fputc(c, <span class="built_in">stdout</span>)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<pre><code>练习:
    利用fgetc和fputc实现，从键盘中获取字符，再回显到标准输出上，
    直到遇到&#39;#&#39;


(2) 每次一行读写
    gets/fgets ---&gt;用来一次获取多个字符(字符串 string)
    puts/fputs ---&gt;用来一次输出多个字符(字符串 string)
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    gets用来从标准输入流(<span class="built_in">stdin</span>)获取多个字符(一行)，</span><br><span class="line">    存储到s指向的内存空间中去。</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">    NOTE:</span><br><span class="line">        gets有一个巨大的bug, 你懂的。</span><br><span class="line">        gets没有考虑到s指向的空间的大小问题，存在越界的风险。</span><br><span class="line">        所以从今天开始，gets你们就不能用啦，除非你将来有一天像我</span><br><span class="line">        一样，当讲师，需要跟学生演示这个bug!!!</span><br><span class="line"></span><br><span class="line">        熊大说，既然这个函数有bug,不能用啦，为什么标准IO库不干掉这个</span><br><span class="line">        函数呢?</span><br><span class="line">            当一个反而教材，警示程序员。</span><br><span class="line"></span><br><span class="line">    fgets修正了gets的这个bug.</span><br><span class="line">    fgets用来从stream指定的文件流中，获取顶多size个字符到s指向的空间.</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;   </span><br><span class="line">        s:指向的空间用来存储获取到的字符(多个)</span><br><span class="line">        size: 指定了s指向的空间的大小(最多能存储多少个字符)</span><br><span class="line">            fgets输入结束有两种情况:</span><br><span class="line">            (<span class="number">1</span>)遇到\n或文件结束</span><br><span class="line">            (<span class="number">2</span>)已经读取到size<span class="number">-1</span>个字节啦(后面留一个\<span class="number">0</span>的位置)</span><br><span class="line">        stream:FILE*，表示从哪个文件流中读取数据</span><br><span class="line">        返回值:</span><br><span class="line">            成功返回s的首地址</span><br><span class="line">            失败返回<span class="literal">NULL</span>,同时errno被设置</span><br><span class="line">        gets(s) =&gt; fgets(s, size, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>用来把s指向的字符串，输出到stream指定文件中去。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">    <span class="built_in">puts</span>用来把s指向的字符串(外加一个\n)，输出到标准输出流(<span class="built_in">stdout</span>)</span><br><span class="line">    <span class="built_in">puts</span>(s) &lt;=&gt;</span><br><span class="line">         <span class="built_in">fputs</span>(s, <span class="built_in">stdout</span>);</span><br><span class="line">         <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    返回值:</span><br><span class="line">        成功返回非负数</span><br><span class="line">        失败返回EOF(<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<pre><code>(3) 二进制文件的读写
    fread
    fwrite
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fread, fwrite - binary stream input/output</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">            fread用来从stream指定的文件流中，读取n个对象(且每个对象size个字节)</span><br><span class="line">            到ptr指向的空间中去</span><br><span class="line">       <span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream)</span></span>;</span><br><span class="line">            ptr：指向的内存空间，用来保存从文件流读取到的<span class="string">&quot;数组&quot;</span></span><br><span class="line">            size: 每个元素占的字节大小</span><br><span class="line">            n:要读取的元素个数</span><br><span class="line">            stream:表示要从哪个文件流读取数据</span><br><span class="line">            返回值:</span><br><span class="line">                成功返回实际读取到的元素个数. &lt;= n</span><br><span class="line">                失败返回<span class="number">-1</span>,同时errno被设置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            fwrite用来把ptr指向的n个对象(每个对象size个字节)写入到</span><br><span class="line">            stream指定的文件流中去。</span><br><span class="line">       <span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n, FILE *stream);</span><br><span class="line">            ptr:指向要写入文件中的元素的首地址</span><br><span class="line">            size: 每个元素占的字节大小</span><br><span class="line">            n:要写入多少个元素</span><br><span class="line">            stream:表示要写到哪个文件中去</span><br><span class="line">            返回值:</span><br><span class="line">                成功返回实际写入到文件流中去的元素个数(不是字节数) &lt;=n</span><br><span class="line">                失败返回<span class="number">-1</span>,同时errno被设置</span><br></pre></td></tr></table></figure>

<pre><code>练习：
    有一个学生信息结构体,如下:
        struct student
        &#123;
            int num;
            float score;
        &#125;;
    从键盘上输入每个学生的信息，然后通过标准IO库的函数，
    把学生信息写入到文件 student.db中去
</code></pre>
<h2 id="3-3-冲洗流-刷新流-“同步”"><a href="#3-3-冲洗流-刷新流-“同步”" class="headerlink" title="3.3 冲洗流/刷新流 “同步”"></a>3.3 冲洗流/刷新流 “同步”</h2><pre><code>fflush
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fflush - flush a stream</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">            stream:要同步/要更新的文件流</span><br><span class="line">            返回值:</span><br><span class="line">                成功返回<span class="number">0</span></span><br><span class="line">                失败返回<span class="number">-1</span>,同时errno被设置</span><br><span class="line">DESCRIPTION</span><br><span class="line">        对输出流，fflush会把写缓冲区的内容，通过底层的write函数写/更新到文件中去;</span><br><span class="line">        对输入流，fflush会把读缓冲区的内容直接discards(丢弃)</span><br><span class="line">        stream == <span class="literal">NULL</span>, fflush把该进程所有打开的输出文件流同步。</span><br></pre></td></tr></table></figure>

<pre><code>练习:
    请分析如下程序的输出结果?
        #include &lt;stdio.h&gt;
        #include &lt;unistd.h&gt;
        main()
        &#123;
            printf(&quot;hello&quot;);
            sleep(10);
            fflush(NULL);
            while (1)
            &#123;

            &#125;
        &#125;
</code></pre>
<h2 id="3-4-定位流"><a href="#3-4-定位流" class="headerlink" title="3.4 定位流"></a>3.4 定位流</h2><pre><code>&quot;定位光标&quot;:一般来说，每次读可写之前，先要定位流。
fseek/ftell/rewind
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    fseek用来定位文件流</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">    stream:文件流指针，表示您要定位哪个文件</span><br><span class="line">    offset:偏移量，可正可负，具体的含义，结合第三个参数</span><br><span class="line">    whence:定位的方式，有如下三种:  </span><br><span class="line">        SEEK_SET: 基于文件开头定位</span><br><span class="line">            新光标位置=文件开头+offset(&gt;=<span class="number">0</span>)</span><br><span class="line">        SEEK_CUR：current基于当前光标位置定位</span><br><span class="line">            新光标位置=当前位置+offset(可正可负)</span><br><span class="line">        SEEK_END: end基于文件末尾定位</span><br><span class="line">            新光标位置=文件末尾+offset(可正可负)</span><br><span class="line">    返回值：</span><br><span class="line">        成功返回<span class="number">0</span></span><br><span class="line">        失败返回<span class="number">-1</span>,同时errno被设置</span><br><span class="line"></span><br><span class="line">    ftell返回当前光标位置离文件开头有多少个字节</span><br><span class="line"><span class="keyword">long</span> ftell(FILE *stream);</span><br><span class="line">    </span><br><span class="line">    rewind把文件光标，定位在文件开头</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">    rewind(stream) =&gt; fseek(stream,<span class="number">0</span>,SEEK_SET);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-文件出错-文件结束标记"><a href="#3-5-文件出错-文件结束标记" class="headerlink" title="3.5 文件出错/文件结束标记"></a>3.5 文件出错/文件结束标记</h2><pre><code>EOF: End Of File 文件结束标记
</code></pre>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    feof用来判断stream指定的文件流是否结束</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">    返回值：</span><br><span class="line">        返回真(非<span class="number">0</span>),如果文件到达末尾啦</span><br><span class="line"></span><br><span class="line">    clearerr用来清掉文件出错标记      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    ferror用来判断stream指定的文件流是否出错</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">    返回值：</span><br><span class="line">        返回真(非<span class="number">0</span>) ,如果 文件出错啦</span><br><span class="line"></span><br><span class="line">NOTE:</span><br><span class="line">    标准IO库，在读到文件末尾时，会往缓冲区填入一个</span><br><span class="line">    EOF(二进制<span class="number">11111111</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-6-格式化IO"><a href="#3-6-格式化IO" class="headerlink" title="3.6 格式化IO"></a>3.6 格式化IO</h2><pre><code>(1) 格式化输入
(2) 格式化输出
</code></pre>
<h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4. 作业"></a>4. 作业</h2><pre><code>创建一个stu.db的文件，存放每个学生的信息结构体，另外
在建一个stu_score.index索引文件，依次存放成绩降序学生结构体在
stu.db中的偏移量(int) 
</code></pre>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
</search>
