<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我搬家了</title>
    <url>/2021/05/30/%E6%88%91%E6%90%AC%E5%AE%B6%E4%BA%86/</url>
    <content><![CDATA[<p>现在有两个博客，这个就拿来记录日常事，另外一个拿来当学习笔记用</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>假期</title>
    <url>/2021/06/19/%E5%81%87%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="First-–-01-链表操作"><a href="#First-–-01-链表操作" class="headerlink" title="First – 01    (链表操作)"></a>First – 01    (链表操作)</h2><span id="more"></span>

<h3 id="1、vscode-连接ubuntu-连接虚拟机上的Ubuntu"><a href="#1、vscode-连接ubuntu-连接虚拟机上的Ubuntu" class="headerlink" title="1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :"></a>1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :</h3><p>1、ubuntu 安装ssh :  sudo apt-get install ssh</p>
<p>2、 vscode 终端命令 :  ssh  (用户名)@ IP     //连接  （vscode安装ssh   client  插件）</p>
<p><img src="https://pic.imgdb.cn/item/60dbd5795132923bf8015adc.png"></p>
<p>3、虚拟机上网：网络桥接模式</p>
<h3 id="2、递归版本的有序链表插入"><a href="#2、递归版本的有序链表插入" class="headerlink" title="2、递归版本的有序链表插入"></a>2、递归版本的有序链表插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Insert</span><span class="params">(Node *h,Node *p)</span>  <span class="comment">//递归方式插入有序链表  返回头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;= h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &gt; h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Insert(h-&gt;next,p); <span class="comment">//递归  最后吐出来的是头结点后面的位置</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、非递归的插入方法"><a href="#3、非递归的插入方法" class="headerlink" title="3、非递归的插入方法"></a>3、非递归的插入方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到插入位置</span></span><br><span class="line"><span class="comment">//分情况讨论  找到和没找到</span></span><br><span class="line"></span><br><span class="line">Node *pk = h;  <span class="comment">//pk指向</span></span><br><span class="line">Node *pr = <span class="literal">NULL</span>;  <span class="comment">//pr指向pk的前驱点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pk-&gt;data &gt;= p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pr = pk;</span><br><span class="line">    pk = pk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pk == <span class="literal">NULL</span>)   <span class="comment">//最后一个</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    pr-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pk == h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        h = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中间插入</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        pr-&gt;next =p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为x的结点</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除算法:</span></span><br><span class="line">    <span class="comment">//1. 找到要删除的结点</span></span><br><span class="line">    <span class="comment">// 遍历链表找到值为x的结点(要删除的结点)px及它前驱结点pr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 分情况删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//px指向要删除的结点</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>; <span class="comment">//pr指向px的前驱结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//px每次搜索开始的那个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        px = ps;</span><br><span class="line">        <span class="keyword">while</span> (px)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps = px-&gt;next; <span class="comment">//下一次搜索的起点就是要删除的结点的下一个!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == h)</span><br><span class="line">        &#123;</span><br><span class="line">            h = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;next = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X_v2</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        Node *px = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Delete_X_v2(h,x);  <span class="comment">//如果后面还有待删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Delete_X_v2(h-&gt;next, x);   <span class="comment">//递归删除中间的结点</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事-实训(智能家居系统)</title>
    <url>/2021/06/16/%E6%97%A5%E5%B8%B8%E4%BA%8B-2/</url>
    <content><![CDATA[<p>为期三周的实训告一段落。</p>
<span id="more"></span>

<h1 id="完成智能家居系统"><a href="#完成智能家居系统" class="headerlink" title="完成智能家居系统"></a>完成智能家居系统</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>学习Zigbee 无线局域网 的组网技术。 </p>
<p>开发工具包：Ztack 协议栈  软件：一个下载软件 ，一个编译软件。 以.hex文件烧录到Zigbee模块。外设有：LED灯，温度，湿度检测，按键。</p>
<p>成品:1.一个模块作为适配器，适配器是局域网组网的原点。2、共有三种模式：适配器模式，路由器模式和终端模式  3、适配器和终端组网通信，通过串口打印信息。</p>
<h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p>学习C++基础知识。新知识点：构造函数的知识，编译器优化和不优化的区别以及指令。《Prime C++》看完，内容多而杂。后期提升多敲代码。对C++颇感兴趣</p>
<h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p>学习QT的知识。</p>
<p>重中之重。。看完B站上的QT教程 <a href="https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14">https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14</a> </p>
<p>如今，着重运用的技术有：信号和槽、各种组件类的运用，QT提供的服务(主要存放在.obj文件上)。-&gt;QT程序在Linux环境上的交叉编译，生成可执行文件。传输到GEC6818开发板上运行程序。</p>
<p>总结:QT的基本概念清晰。但是，软肋就是不会折腾。室友夜以继日的卷，明显自己的基本了解完全不行&gt;__&lt; 。 外加美术功底的问题，界面设计实在不太理想。。</p>
<h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>多多更新博客，多多上传项目到github，多多折腾</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx那些事</title>
    <url>/2021/06/04/nginx%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="Nginx那些事儿"><a href="#Nginx那些事儿" class="headerlink" title="Nginx那些事儿"></a>Nginx那些事儿</h2><p>nginx简介：<strong>高性能的HTTP</strong>和<strong>反向代理Web服务器</strong>，提供各种服务 IMAP/POP3/SMTP 等等服务。</p>
<span id="more"></span>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>(1)正向代理:在客户端需要配置代理服务器，通过代理服务器进行互联网访问</p>
<p>(2)反向代理：客户端不需要配置 反向代理服务器 。 对外，反向代理服务器和目标是一个服务器</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>QT那些事儿(1)</title>
    <url>/2021/05/15/QT%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-1/</url>
    <content><![CDATA[<h2 id="QT那些事儿（1）"><a href="#QT那些事儿（1）" class="headerlink" title="QT那些事儿（1）"></a>QT那些事儿（1）</h2><h3 id="1、QT是神马？"><a href="#1、QT是神马？" class="headerlink" title="1、QT是神马？"></a>1、QT是神马？</h3><span id="more"></span>

<blockquote>
<p><strong>关于QT的介绍呢，让我们乘上时光机</strong> <a href="https://zhuanlan.zhihu.com/p/140489718">https://zhuanlan.zhihu.com/p/140489718</a> <strong>一探究竟</strong></p>
</blockquote>
<p>QT呢，是C++御用图形用户界面应用程序框架，与 <u><strong>嵌入式Liunx</strong></u>，<strong>C++</strong> 的开发密不可分。</p>
<blockquote>
<p><strong>先学C++基础语法，基本数据类型，两个复合类型，几种主要的语句，类最基本的创建，构造，析构，就可以学Qt，在Qt中逐渐学会类的构建，类的特性，继承，多态等等，学Qt的时候慢慢感受类，能让你对类和面向对象有更深入的理解，而且可以模仿Qt框架类的实现，它本身就是C++的一个类群</strong></p>
</blockquote>
<h3 id="2、面向offer的编程"><a href="#2、面向offer的编程" class="headerlink" title="2、面向offer的编程"></a>2、面向offer的编程</h3><p>作为一名合格的程序员呢，应该有自己的一套核心技术栈，采集与某 app 的职位招聘信息</p>
<p>（1）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6f946ae4f77d3520011f.jpg"></p>
<p>（2）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6fcf6ae4f77d352323b8.jpg"></p>
<p>（3）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6ff26ae4f77d352524d9.jpg"></p>
<p><em><strong>高薪offer冲冲冲</strong> ✌</em></p>
]]></content>
      <tags>
        <tag>QT那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事</title>
    <url>/2021/05/11/%E6%97%A5%E5%B8%B8%E4%BA%8B/</url>
    <content><![CDATA[<p>冲浪发现的博客</p>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/609a400dd1a9ae528f35806c.png"></p>
<blockquote>
<p><a href="https://wujun234.github.io/">https://wujun234.github.io/</a></p>
</blockquote>
<p>有时候找些想要学的途径，杂七杂八的不好下手，非常好的知识梳理框架，康康大佬是怎么学习的</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之旅(1)</title>
    <url>/2021/05/09/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-1/</url>
    <content><![CDATA[<h1 id="学习之旅-1"><a href="#学习之旅-1" class="headerlink" title="学习之旅(1)"></a>学习之旅(1)</h1><p>本篇章记录自己的学习生活。至于有多少后序呢，，，，，，</p>
<span id="more"></span>

<p>写博客嘞，找点素材，有时间把博客功能丰富一下。作为一名学习参与者，记录一下近期的学习的晋升之旅</p>
<p><em>现阶段呢，还是以啃书为主。各种书的资源呢，也许我会上传到github</em></p>
<h2 id="1、C-的学习"><a href="#1、C-的学习" class="headerlink" title="1、C++的学习"></a>1、C++的学习</h2><p>先说一下对学习C++的印象哈，语言的学习嘛，多而杂。最近在啃那个《Primer C++》</p>
<p>就这：</p>
<p><img src="https://pic.imgdb.cn/item/6097861cd1a9ae528f259d63.png"></p>
<p>有人会说啊，这个这个语言不就那几个循环啊，条件判断什么的嘛，过一遍就行。这样下去是不行滴昂，比如说，变量声明和定义的区别，作用域的理解啊。。。巴拉巴拉，语言的学习呢，还是要细致一点滴。经过C语言学习的惨痛教训呢(当时没认真听课)，深刻认识到语言的学习要细致入微。这本书呢，还是C++入门级别 &gt;__&lt;，别急，慢慢来，时间多的很。</p>
<blockquote>
<p><a href="https://light-city.club/sc/">https://light-city.club/sc/</a>  ，这个呢，是一个大佬的晋升之路。至于自己能走到哪，看造化吧。  </p>
</blockquote>
<h2 id="2、LeetCode-算法刷题"><a href="#2、LeetCode-算法刷题" class="headerlink" title="2、LeetCode 算法刷题"></a>2、LeetCode 算法刷题</h2><p>比起C++呢，这个篇章没有那么多，那么杂。But,but,真的耗时间。算法嘛，相当于修炼内功了，打好扎实的基础还是很有好处滴</p>
<p><img src="https://pic.imgdb.cn/item/60978afdd1a9ae528f608a6e.png"></p>
<p>这本书呢，是一个Google大佬编的，对我呢还是挺友好的，现在看到了那个分治法。刷题也要先学基本功对不对，进力扣网站，刚开始就整一些动态规划啊，贪心算法巴拉巴拉的名词，一道题刷一天也不是办法对不对。</p>
<h2 id="3、Linux-Unix系统开发的学习"><a href="#3、Linux-Unix系统开发的学习" class="headerlink" title="3、Linux /Unix系统开发的学习"></a>3、Linux /Unix系统开发的学习</h2><p>因为呢，本身是走嵌入式开发学习方向的啊，Linux 的学习必不可少。之前几个学期呢，学了Shell 编程啊，进程开发，通信啊，文件IO什么的。又说呢，学习要细致，来，上干货啃书。</p>
<p><img src="https://pic.imgdb.cn/item/60978d33d1a9ae528f80c0aa.png"></p>
<p>嘶，，822页。但是呢，我之前五一啃完了一本Linux 系统编程。看着目录还行，内容上面都是老熟人了，得空就啃了。</p>
<h2 id="4、数据结构的学习"><a href="#4、数据结构的学习" class="headerlink" title="4、数据结构的学习"></a>4、数据结构的学习</h2><p>3月份呢，过了一遍数据结构的书，但是呢，现在基本忘光。二刷，不就树啊，图什么的。</p>
<h2 id="5、英语"><a href="#5、英语" class="headerlink" title="5、英语"></a>5、英语</h2><p>6月份考六级了，现在呢，单词准备过第二遍，刷十几套试卷什么的，这不，上午刚了<u>七十几个</u>单词 ，不是吹的，主要是第二遍，速度比较抓紧一点。刷试卷还是要刷滴，英语考试对我来说就是考题感，感觉刷上来了什么都好说。</p>
<p>完，暂时就这些，后期呢，准备搞一下网络，单片机，ARM开发的复习，还有搞一下QT的学习。下午的话搞一下这个博客的使用，再看一下科目四，星期二就要拿证了，芜湖~</p>
]]></content>
      <tags>
        <tag>学习之旅</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2021/05/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><span id="more"></span>

<p>在搜索到一个新的节点时，立即对该新节点进行遍历，需要依靠先入后出的栈来实现，也可以通过与栈等价的递归来实现。也可以用来检测环路。拓扑排序可以判断是否有环路。</p>
<h3 id="1、最大水洼求值"><a href="#1、最大水洼求值" class="headerlink" title="1、最大水洼求值"></a>1、最大水洼求值</h3><p>Input: [[1,0,1,1,0,1,0,1], </p>
<p>​           [1,0,1,1,0,1,1,1],</p>
<p>​           [0,0,0,0,0,0,0,1]]                    Output: 6</p>
<h4 id="递归思路："><a href="#递归思路：" class="headerlink" title="递归思路："></a>递归思路：</h4><p>​           (1)  分为主函数( 用于遍历判断” 1 “ 的位置，开始递归搜索 )和辅函数( 用于递归搜索”1”的位置)</p>
<p>​           (2) 辅函数中逢”1” 置 “0” ，临近水洼置”0” , 避免重复判断</p>
<p>​           (3)递归搜索时，边界(矩阵越界)判断方法两种：先判断是否越界再开始搜索（即判断放在调用 递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合 法（即判断放在辅函数第一行）。</p>
<p>第一种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//判断上下左右的位置</span></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;   <span class="comment">//遍历二维数组得到陷入递归函数的调用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;   <span class="comment">//判断水洼陷入递归函数调用</span></span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));  <span class="comment">//比较函数，得到最大数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y, area = <span class="number">1</span>;   <span class="comment">//每一次递归(取到一个&quot;1&quot;)都会return 一个area,最后累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];   <span class="comment">//取四个方向的递归</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);   <span class="comment">//累计水洼数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() ||c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的写法："><a href="#栈的写法：" class="headerlink" title="栈的写法："></a>栈的写法：</h4><p>关于图片加载的问题：上传到github ,下一篇开始采用聚合图床上传</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B0%B4%E6%B4%BC.png" alt="水洼"></p>
<p>思路：针对每一个入栈的元素 [r , c] 都进行4次的坐标入栈。 local_area 的累加都在判断中间。max 的 取值都在主循环</p>
<h3 id="2、海流方向"><a href="#2、海流方向" class="headerlink" title="2、海流方向"></a>2、海流方向</h3><p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B5%B7%E6%B5%81%E6%96%B9%E5%90%91.png"></p>
<p>思路：因此我们可以反过来想，从两个大洋开始向上流，这样我们 只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋 向上流都能到达的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到太平洋</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到大西洋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);    <span class="comment">//左边开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);  <span class="comment">//从右边开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);    <span class="comment">//从上面开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);   <span class="comment">//从下面开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);      <span class="comment">//两大洋都能流到，压栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; can_reach,<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;   <span class="comment">//满足条件(找到最高点即退出循环，可以先置&quot;true&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>()</span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            matrix[r][c] &lt;= matrix[x][y]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);  <span class="comment">//判断条件为：边界判断以及最高点条件判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><blockquote>
<p>[修改当前节点状态]→[递归子节点]→[回改当前节点 状态]。         此路不通，修改之前一步的状态，回退一步，继续搜索。</p>
</blockquote>
<h3 id="1、全排列"><a href="#1、全排列" class="headerlink" title="1、全排列"></a>1、全排列</h3><p>[1,2,3]  的可能排列方式 ，题解可以采用树形结构：</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E5%85%A8%E6%8E%92%E5%88%97.png" alt="全排列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>1、level 为树的层次，递归的终止条件为：level == nums.size() -1,到树底部终结递归</p>
<p>2、for循环中的 level 和 level+1 ，每次递归都会随着树的深度增加而发生变化，但是始终没有改变值。(栈空间的临时存储)。</p>
<p>3、过程模拟:  第一棵树： i = 0,level=0 , 即[1,2,3],进行交换。子树里面,level增加，i又要从level到nums.size()-1来分配情况。第一个确定，依据 level 来交换情况</p>
<p>4、i+1 的时候要回退一步(回到根节点来进行回溯)。在修改结点，递归后面回退根节点的状态，即swap(nums[i],nums[level]);</p>
<h3 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h3><p>Input: n = 4, k = 2 </p>
<p>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;  <span class="comment">//最后输出数据</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);  <span class="comment">//count 计算深度,comb临时两个[a,b]数组，&quot;1&quot;为初始位置开始也可看做深度</span></span><br><span class="line">    <span class="comment">//count作为数组的编号取值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; comb, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  pos, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; ++i) &#123;</span><br><span class="line">        comb[count++] = i; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k); <span class="comment">// 递归子节点</span></span><br><span class="line">        --count; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E7%BB%84%E5%90%88.png"></p>
<h3 id="3、字符串搜索"><a href="#3、字符串搜索" class="headerlink" title="3、字符串搜索"></a>3、字符串搜索</h3><p>Input: word = “ABCCED”, board = [[’A’,’B’,’C’,’E’],</p>
<p>​                                                        [’S’,’F’,’C’,’S’], </p>
<p>​                                                        [’A’,’D’,’E’,’E’]] </p>
<p>Output: true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="keyword">bool</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  &amp; find, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">    <span class="comment">// 递归子节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>广度优先搜索(BFS)采用先进先出的队列结构，深度优先采用先进后出的栈结构</p>
<h3 id="1、两个岛屿最小距离"><a href="#1、两个岛屿最小距离" class="headerlink" title="1、两个岛屿最小距离"></a>1、两个岛屿最小距离</h3><p>(深度优先查找一个岛屿的位置，全部置为”2” , 接着从岛屿的各个周围遍历，直到找到另一个岛屿，即是最短距离)</p>
<p>Input: </p>
<p>​          [[1,1,1,1,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,0,1,0,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,1,1,1,1]] </p>
<p>Output: 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="comment">// dfs寻找第一个岛屿，并把1全部赋值为2</span></span><br><span class="line">    <span class="keyword">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs寻找第二个岛屿，并把过程中经过的0赋值为2</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();   <span class="comment">//n个临近海域搜索，完结后进入第二级海域</span></span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n</span></span></span><br><span class="line"><span class="function"><span class="params">         , <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--points队列里面存的是临近第一个小岛的海域-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>1、有序数列的查找</p>
<p>返回元素第一次出现的位置和最后一次出现的位置</p>
<span id="more"></span>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mylower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myupper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> lower = <span class="built_in">mylower_bound</span>(nums, target);</span><br><span class="line">	<span class="keyword">int</span> upper = <span class="built_in">myupper_bound</span>(nums, target) - <span class="number">1</span>; <span class="comment">// 这里需要减1位</span></span><br><span class="line">	<span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">		<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2 = <span class="built_in">searchRange</span>(v1,i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;含有 7 的区间为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; v2.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v2[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、二分查找的开区间和闭区间"><a href="#2、二分查找的开区间和闭区间" class="headerlink" title="2、二分查找的开区间和闭区间"></a>2、二分查找的开区间和闭区间</h3><p>一般查找分为 左闭右开 和 左闭右闭两种情况：</p>
<p><a href="https://blog.csdn.net/blue_coffeei/article/details/91476091">https://blog.csdn.net/blue_coffeei/article/details/91476091</a></p>
<h3 id="3、牛顿迭代法（开平方）"><a href="#3、牛顿迭代法（开平方）" class="headerlink" title="3、牛顿迭代法（开平方）"></a>3、牛顿迭代法（开平方）</h3><p>其公式为 xn+1 = xn − f (xn)/ f ′ (xn)。给 定 f (x) = x 2 − a = 0，这里的迭代公式为 xn+1 = (xn + a/xn)/2，其代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> x = a;</span><br><span class="line">		<span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">			x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、旋转数组查找法"><a href="#4、旋转数组查找法" class="headerlink" title="4、旋转数组查找法"></a>4、旋转数组查找法</h3><p>1.查找旋转数组的最小值</p>
<p>Input: nums = [2,5,6,0,0,1,2],</p>
<p>思路：三种情况</p>
<p>1、nums [mid] &lt; nums [r] =&gt; mid 位于右区间，右区间有序</p>
<p>2、nums[mid] &gt; nums [r] =&gt; mid 位于左区间，左区间有序</p>
<p>3、nums[mid] = nums[r] =&gt; 重复的值，r - -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>,<span class="built_in">len</span>(numbers-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> left&lt;right:</span><br><span class="line">     mid = (left+right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> numbers[mid] &gt; numbers[right]; <span class="string">&quot;&quot;&quot;位于左区间&quot;&quot;&quot;</span></span><br><span class="line">       left = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elif</span> numbers[mid] &lt; numbers[right]; <span class="string">&quot;&quot;&quot;位于右区间&quot;&quot;&quot;</span></span><br><span class="line">       right = mid;    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> numbers[left]</span><br></pre></td></tr></table></figure>

<!--因为是查找最小值，区间的收缩会不一样-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/05/hello-world/</url>
    <content><![CDATA[<p>临阵磨枪一波，搞个博客。</p>
<blockquote>
<p>入坑教程：<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a></p>
</blockquote>
]]></content>
  </entry>
</search>
