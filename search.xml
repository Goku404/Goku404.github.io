<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于博客</title>
    <url>/2021/05/30/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>博客的更新是很有必要的，有两个博客。</p>
<span id="more"></span>

<p>本博客基于 hexo 主题和 github静态页面。入坑教程:<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a>  </p>
<p>另一个博客基于腾讯云的轻量服务器的wordpress应用，为动态博客。域名还未申请。</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>假期4</title>
    <url>/2021/07/07/%E5%81%87%E6%9C%9F(4)/</url>
    <content><![CDATA[<h2 id="这孩子打小就聪明"><a href="#这孩子打小就聪明" class="headerlink" title="这孩子打小就聪明"></a>这孩子打小就聪明</h2><span id="more"></span>

<p>关于二叉树的递归问题</p>
<h3 id="1、求出二叉树的高度"><a href="#1、求出二叉树的高度" class="headerlink" title="1、求出二叉树的高度"></a>1、求出二叉树的高度</h3><p>递归思路：设置一个宏，比较两个数的最大值   返回左子树函数调用和右子树函数调用加1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b) ?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX(level(t-&gt;lchild),level(t-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、求出数的最大结点"><a href="#2、求出数的最大结点" class="headerlink" title="2、求出数的最大结点"></a>2、求出数的最大结点</h3><p>递归思路:如果右子树存在，返回右子树的函数调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Bitree *<span class="title">max</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、删除整个二叉树"><a href="#3、删除整个二叉树" class="headerlink" title="3、删除整个二叉树"></a>3、删除整个二叉树</h3><p>递归思路：删除左子树，删除右子树，删除本身结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Bitree *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;lchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;rchild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(3)</title>
    <url>/2021/07/05/%E5%81%87%E6%9C%9F(3)/</url>
    <content><![CDATA[<h1 id="Third-03-树"><a href="#Third-03-树" class="headerlink" title="Third 03  树"></a>Third 03  树</h1><p>10.40</p>
<span id="more"></span>

<p>详细教程:<a href="https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">https://wujun234.github.io/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a></p>
<h2 id="1、树和二叉树的基本概念"><a href="#1、树和二叉树的基本概念" class="headerlink" title="1、树和二叉树的基本概念"></a>1、树和二叉树的基本概念</h2><p>度为零的结点称之为叶子结点，度不为零的称之为非终端结点。最大层次为树的高度或深度</p>
<h2 id="2、二叉树-Binary-Tree"><a href="#2、二叉树-Binary-Tree" class="headerlink" title="2、二叉树(Binary Tree)"></a>2、二叉树(Binary Tree)</h2><p>每个结点最多只有两棵子树(不存在 度大于2 的结点) </p>
<p>满二叉树:在不增加树的高度下，没法在树中添加结点</p>
<p>完全二叉树:  (1) 除去最后一层，这棵树是满二叉树 (2)最后一层靠左边</p>
<p>二叉树性质:    </p>
<p>遍历方法：前序遍历，中序遍历，后序遍历都可以用递归来实现  层序遍历需要用到队列的方法</p>
<h3 id="1、tip-层序遍历-二叉树的层序遍历运用到队列操作"><a href="#1、tip-层序遍历-二叉树的层序遍历运用到队列操作" class="headerlink" title="1、tip:层序遍历:  二叉树的层序遍历运用到队列操作"></a>1、tip:层序遍历:  二叉树的层序遍历运用到队列操作</h3><ul>
<li><p>首先，根结点 1 入队；</p>
</li>
<li><p>根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；</p>
</li>
<li><p>队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；</p>
</li>
<li><p>队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；</p>
</li>
<li><p>不断地循环，直至队列内为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//根节点入队 Queue, 队列存储的类型应该是结点类型的</span></span><br><span class="line">Enqueue(q,p); </span><br><span class="line"><span class="keyword">while</span>(队列不为空)   <span class="comment">//层序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    p = Dequeue(q,p);  <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Enqueue(q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代方式实现遍历"><a href="#2、迭代方式实现遍历" class="headerlink" title="2、迭代方式实现遍历"></a>2、迭代方式实现遍历</h3><p>详细教程:</p>
<p><a href="https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">https://blog.csdn.net/char_m/article/details/105648703?utm_source=app&amp;app_version=4.10.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen</a></p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>1、首先创建一个栈，初始情况下，把根节点入栈</p>
</li>
</ul>
<p>​       2、进入循环<br>​       a）取栈顶元素（出栈）<br>​       b）访问该元素<br>​       c）如果该元素的右子树不为空，就入栈；如果左子树不为空也入栈，当栈为空时，遍历完成。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>​        1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​        2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​        3、当cur为空，（此时栈顶元素是目前的最左侧元素），出栈并访问<br>​        4、让cur指向刚刚被访问的节点的右子树，循环2、3、4步骤</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>​       1、需要创建一个栈，设定一个cur引用从根节点出发</p>
<p>​       2、只要cur不为空就把cur入栈，同时cur向左移直到cur为空。<br>​       3、当cur为空，取栈顶元素（如果栈顶元素被访问即被打印才可出栈，否则依然在栈里面），判断是否能够访问：<br>​       a）可以访问：<br>​       如果栈顶元素右子树为null，则可以访问<br>​       栈顶元素已经被访问过了，则可以访问，定义一个prev变量记录上一个被访问过的元素<br>​       b）不能访问：<br>​       让cur从栈顶元素的右子树出发继续进行1、2、3步骤</p>
<h2 id="3、二叉排序树的删除"><a href="#3、二叉排序树的删除" class="headerlink" title="3、二叉排序树的删除"></a>3、二叉排序树的删除</h2><p>步骤：先找到待删除的结点，然后据情况判断</p>
<p>1、如果结点没有孩子，直接删除</p>
<p>2、如果只有一个孩子，父结点直接指向孩子结点，删除该结点</p>
<p>3、如果 px 两个孩子都有，找到左子树的最大值作为”替罪羊” ，它的值赋给px，然后跳到开头处理px 的操作进行删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">DeleteX</span><span class="params">(BiTNode *t, TElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BiTNode *px = t; <span class="comment">//指向要删除的结点</span></span><br><span class="line">    BiTNode *pf; <span class="comment">//指向px的父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先找到要删除的结点</span></span><br><span class="line">    <span class="keyword">while</span> (px)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; px-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">delete_op:</span><br><span class="line">    <span class="comment">//! 找到了，分情况删除</span></span><br><span class="line">    <span class="keyword">if</span> (px-&gt;lchild == <span class="literal">NULL</span> &amp;&amp;  px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (px == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == pf-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//! px只有右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;lchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;rchild;</span><br><span class="line">            px-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( px-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px只有左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(t == px)</span><br><span class="line">        &#123;</span><br><span class="line">            t = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pf-&gt;lchild == px)</span><br><span class="line">        &#123;</span><br><span class="line">           pf-&gt;lchild = px-&gt;lchild;</span><br><span class="line">           px-&gt;lchild =<span class="literal">NULL</span>;</span><br><span class="line">           <span class="built_in">free</span>(px);</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//pf-&gt;rchild == px</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rchild = px-&gt;lchild;</span><br><span class="line">            px-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! px左右孩子俱全</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要找一个“替罪 yang”</span></span><br><span class="line">        <span class="comment">// 找左边最大值结点:左拐-&gt;右拐-&gt;右拐 ...</span></span><br><span class="line"></span><br><span class="line">        BiTNode *r = px;</span><br><span class="line"></span><br><span class="line">        pf  = px;</span><br><span class="line">        px = px-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (px-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf = px;</span><br><span class="line">            px = px-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r-&gt;data = px-&gt;data; <span class="comment">//!  </span></span><br><span class="line">        <span class="keyword">goto</span> delete_op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、树，二叉树。森林的转换"><a href="#4、树，二叉树。森林的转换" class="headerlink" title="4、树，二叉树。森林的转换"></a>4、树，二叉树。森林的转换</h2><p>树 &lt;-&gt; 二叉树 :   </p>
<ol>
<li><img src="https://pic.imgdb.cn/item/60e43c5c5132923bf8ce7b96.jpg"></li>
</ol>
<p>（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</p>
<p>2、森林转换成二叉树</p>
<ol>
<li>把每棵树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
<li><img src="https://pic.imgdb.cn/item/60e43e475132923bf8d67d22.jpg"></li>
</ol>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>假期(2)</title>
    <url>/2021/07/02/%E5%81%87%E6%9C%9F(2)/</url>
    <content><![CDATA[<h2 id="Second-–-02（栈）"><a href="#Second-–-02（栈）" class="headerlink" title="Second – 02（栈）"></a>Second – 02（栈）</h2><p>9.24  AM</p>
<span id="more"></span>

<h2 id="一、小题"><a href="#一、小题" class="headerlink" title="一、小题"></a>一、小题</h2><h3 id="（1）删除结点问题"><a href="#（1）删除结点问题" class="headerlink" title="（1）删除结点问题"></a>（1）删除结点问题</h3><p><img src="https://pic.imgdb.cn/item/60de6b3e5132923bf85b2a6e.png"></p>
<h3 id="2-单链表：写一个函数合并两个升序单链表"><a href="#2-单链表：写一个函数合并两个升序单链表" class="headerlink" title="(2)单链表：写一个函数合并两个升序单链表"></a>(2)单链表：写一个函数合并两个升序单链表</h3><p>要求：不能额外申请空间，合并的链表仍然有序</p>
<p>两种方法:  一种直接一个一个插入</p>
<p>二种:两两pk，谁小往后面挪 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Merge</span><span class="params">(Node* ha, Node* hb)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法一:</span></span><br><span class="line"><span class="comment">      把ha的结点一个一个摘下来，然后按“插入排序”</span></span><br><span class="line"><span class="comment">      插入到hb的链表中去。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*算法二:</span></span><br><span class="line"><span class="comment">      “两两PK,谁小谁往后挪，挪之前先链接起来”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      ph 指向合并后的链表的第一个结点</span></span><br><span class="line"><span class="comment">      pt 指向合并后的链表的最后一个结点*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = ha;</span><br><span class="line">          ha = ha-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          pt = ph = hb;</span><br><span class="line">          hb = hb-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (ha &amp;&amp; hb)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (ha-&gt;data &lt;= hb-&gt;data)</span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = ha;</span><br><span class="line">              pt = ha;</span><br><span class="line">              ha = ha-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              pt-&gt;next = hb;</span><br><span class="line">              pt = hb;</span><br><span class="line">              hb = hb-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ha)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = ha;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hb)</span><br><span class="line">      &#123;</span><br><span class="line">          pt-&gt;next = hb;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ph;</span><br></pre></td></tr></table></figure>

<h3 id="3-对一个单链表进行排序"><a href="#3-对一个单链表进行排序" class="headerlink" title="(3)对一个单链表进行排序"></a>(3)对一个单链表进行排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node*  <span class="title">Sort_Bubble</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span> || h-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *pk = h;  </span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向pk前面的那个结点 </span></span><br><span class="line">    Node *pn = (pk == <span class="literal">NULL</span>) ? <span class="literal">NULL</span>: pk-&gt;next; </span><br><span class="line">        <span class="comment">//pn指向pk后面的那个结点</span></span><br><span class="line"></span><br><span class="line">    Node *ps = <span class="literal">NULL</span>;<span class="comment">//指向后面的那个有序表的第一个结点</span></span><br><span class="line">    Node *r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h != ps)  <span class="comment">//已排序后的部分逼到头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        pk = h;</span><br><span class="line">        pn = pk-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pn != ps)  <span class="comment">//pn后面跟着的是已排好的部分</span></span><br><span class="line">        &#123;</span><br><span class="line">		   <span class="keyword">if</span> (pk-&gt;data &lt;= pn-&gt;data)  <span class="comment">//如果有序的话，直接移位</span></span><br><span class="line">            &#123;</span><br><span class="line">                pr = pk;</span><br><span class="line">                pk = pn;</span><br><span class="line">                pn = pn-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>   <span class="comment">//开始交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                r = pn-&gt;next;</span><br><span class="line">                pn-&gt;next = pk;</span><br><span class="line">                pk-&gt;next = r;</span><br><span class="line">                <span class="keyword">if</span> (pr)</span><br><span class="line">                &#123;</span><br><span class="line">                    pr-&gt;next = pn;</span><br><span class="line">                &#125;</span><br><span class="line">                pr = pn;</span><br><span class="line">                pn = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ps = pk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><p><img src="https://pic.imgdb.cn/item/60debb855132923bf8261c96.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfc8735132923bf8964303.png"></p>
<p><img src="https://pic.imgdb.cn/item/60dfcb965132923bf8ac9a02.png"></p>
<p>​                                                            //  fgets函数的应用  ，其不能识别换行符(回车键),所以进行代替操作   </p>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>栈顶和栈底倒转，头部删除（不需要引入另一个指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="comment">//&quot;数据结点&quot;存放栈元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SELemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;SNode;</span><br><span class="line"></span><br><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">LinkedStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SNode *Bottom; <span class="comment">//指向栈底元素</span></span><br><span class="line">    SNode *Top;  <span class="comment">//指向栈顶的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//链式栈的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>链式栈的清空和销毁：清空表示干掉所有数据结点</p>
<p>销毁表示还要干掉头结点</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队尾(rear):允许插入元素的一端</p>
<p>队头(front):允许删除元素的一端</p>
<p>实现：顺序结构和链式结构，操作：InitQueue  DestroyQueue ClearQueue   QueueIsEmpty  QueueLength</p>
<p>“排队论”</p>
<h3 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="(1)顺序队列"></a>(1)顺序队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现理念：数组，队尾，队首指针，数组的最大长度。</span></span><br><span class="line"><span class="comment">  入队从队尾入，出队从队首出。队尾队首的表示方法都是下标表示</span></span><br><span class="line"><span class="comment">  能够实现空间循环使用的效果：出队或者入队。如果队尾/队首指针达到最大长度时，自动转到下标为零(数组空间开头)</span></span><br><span class="line"><span class="comment">  实现空间的循环利用。实现队列存储操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）链式队列"><a href="#（2）链式队列" class="headerlink" title="（2）链式队列"></a>（2）链式队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据结点类型描述：数据域，前指针和后指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存队元素的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NOde</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node *Front; <span class="comment">//指向队头结点</span></span><br><span class="line">    Node *Rear;  <span class="comment">//指向队尾结点</span></span><br><span class="line">    <span class="keyword">int</span> Length;  <span class="comment">//队列中元素的个数</span></span><br><span class="line">&#125;LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列类型头指针:队首元素的指针 队尾元素的指针 队列元素的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）不采用长度标志位-availuble-标志长度"><a href="#（3）不采用长度标志位-availuble-标志长度" class="headerlink" title="（3）不采用长度标志位   availuble 标志长度"></a>（3）不采用长度标志位   availuble 标志长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//牺牲一个空间，rear 指向最后一个空位表示满</span></span><br><span class="line">(rear + <span class="number">1</span>) % capacity == front  <span class="comment">//队列满</span></span><br><span class="line">front == rear    <span class="comment">//队列为空</span></span><br><span class="line">(rear-front+capacity)%capacity   <span class="comment">//计算元素个数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode</title>
    <url>/2021/07/01/Leetcode/</url>
    <content><![CDATA[<h2 id="复习-day01"><a href="#复习-day01" class="headerlink" title="复习(day01)"></a>复习(day01)</h2><span id="more"></span>

<h2 id="1、双指针"><a href="#1、双指针" class="headerlink" title="1、双指针"></a>1、双指针</h2><h3 id="（1）、合并两个有序数组"><a href="#（1）、合并两个有序数组" class="headerlink" title="（1）、合并两个有序数组"></a>（1）、合并两个有序数组</h3><p><img src="https://pic.imgdb.cn/item/60dda26d5132923bf8e4a2ad.png"></p>
<blockquote>
<p>将num1 扩容到两个数组合并大小三个指针，一个指向待操作的位置，一个指向num1,一个指向num2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> m,vector&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = m-- +n-- <span class="number">-1</span>; <span class="comment">//指向操作的位置</span></span><br><span class="line">    <span class="keyword">while</span>(m &gt;= <span class="number">0</span> &amp;&amp; n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums1[m] &gt; nums[n] ? nums1[m--]:nums2[n--]; <span class="comment">//两边开始走</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nums1[pos--] = nums2[n--]; <span class="comment">//n1走完表示直接添加 n2要继续走完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）快慢指针（判断链表是否有环"><a href="#（2）快慢指针（判断链表是否有环" class="headerlink" title="（2）快慢指针（判断链表是否有环)"></a>（2）快慢指针（判断链表是否有环)</h3><p>判断链表是否有环，可以采用快慢指针，判断入环的位置，需要将快指针调到头结点，然后两个结点再走，碰到一起说明环的初始位置</p>
<h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="(3)滑动窗口"></a>(3)滑动窗口</h3><p>给定两个字符串 S 和 T，求 S 中包含 T 所有字符的最短连续子字符串的长度，同时要求时间 复杂度不得超过 O(n)。</p>
<p><img src="https://pic.imgdb.cn/item/60dda6535132923bf8f5a171.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">chars</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;       <span class="comment">//记录T中的字符情况个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;  <span class="comment">//记录T中的字符情况</span></span><br><span class="line">    <span class="comment">// 先统计T中的字符情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        flag[T[i]] = <span class="literal">true</span>;  <span class="comment">//对应字符情况</span></span><br><span class="line">        ++chars[T[i]];    <span class="comment">//对应字符的个数分布</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动滑动窗口，不断更改统计数据</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, min_l = <span class="number">0</span>, min_size = S.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; S.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[S[r]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--chars[S[r]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若目前滑动窗口已包含T中全部字符，</span></span><br><span class="line">            <span class="comment">// 则尝试将l右移，在不影响结果的情况下获得最短子字符串</span></span><br><span class="line">            <span class="keyword">while</span> (cnt == T.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; min_size) &#123;</span><br><span class="line">                    min_l = l;</span><br><span class="line">                    min_size = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag[S[l]] &amp;&amp; ++chars[S[l]] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="comment">//如果l缩小时，遇到待选字符，退还一个剩余量，并且cnt--,同时l++,r开始向右移动</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_size &gt; S.<span class="built_in">size</span>()? <span class="string">&quot;&quot;</span>: S.<span class="built_in">substr</span>(min_l, min_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><h3 id="（1）求开方"><a href="#（1）求开方" class="headerlink" title="（1）求开方"></a>（1）求开方</h3><p>设置一个非负整数，求它的开方，向下取整</p>
<p>例如： 8  -&gt;  2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>假期</title>
    <url>/2021/06/19/%E5%81%87%E6%9C%9F(1)/</url>
    <content><![CDATA[<h2 id="First-–-01-链表操作"><a href="#First-–-01-链表操作" class="headerlink" title="First – 01    (链表操作)"></a>First – 01    (链表操作)</h2><span id="more"></span>

<h3 id="1、vscode-连接ubuntu-连接虚拟机上的Ubuntu"><a href="#1、vscode-连接ubuntu-连接虚拟机上的Ubuntu" class="headerlink" title="1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :"></a>1、vscode 连接ubuntu  (连接虚拟机上的Ubuntu) :</h3><ul>
<li><p><input checked="" disabled="" type="checkbox">  1、ubuntu 安装ssh :  sudo apt-get install ssh</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  2、 vscode 终端命令 :  ssh  (用户名)@ IP     //连接  （vscode安装ssh   client  插件）</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60dbd5795132923bf8015adc.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 3、虚拟机上网：网络桥接模式</li>
</ul>
<h3 id="2、递归版本的有序链表插入"><a href="#2、递归版本的有序链表插入" class="headerlink" title="2、递归版本的有序链表插入"></a>2、递归版本的有序链表插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">Insert</span><span class="params">(Node *h,Node *p)</span>  <span class="comment">//递归方式插入有序链表  返回头结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &lt;= h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data &gt; h-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Insert(h-&gt;next,p); <span class="comment">//递归  最后吐出来的是头结点后面的位置</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、非递归的插入方法"><a href="#3、非递归的插入方法" class="headerlink" title="3、非递归的插入方法"></a>3、非递归的插入方法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到插入位置</span></span><br><span class="line"><span class="comment">//分情况讨论  找到和没找到</span></span><br><span class="line"></span><br><span class="line">Node *pk = h;  <span class="comment">//pk指向</span></span><br><span class="line">Node *pr = <span class="literal">NULL</span>;  <span class="comment">//pr指向pk的前驱点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pk-&gt;data &gt;= p-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pr = pk;</span><br><span class="line">    pk = pk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pk == <span class="literal">NULL</span>)   <span class="comment">//最后一个</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    pr-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pk == h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//头插法</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        h = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中间插入</span></span><br><span class="line">        p-&gt;next = pk;</span><br><span class="line">        pr-&gt;next =p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除值为x的结点</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除算法:</span></span><br><span class="line">    <span class="comment">//1. 找到要删除的结点</span></span><br><span class="line">    <span class="comment">// 遍历链表找到值为x的结点(要删除的结点)px及它前驱结点pr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 分情况删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//px指向要删除的结点</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>; <span class="comment">//pr指向px的前驱结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//px每次搜索开始的那个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        px = ps;</span><br><span class="line">        <span class="keyword">while</span> (px)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data == x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps = px-&gt;next; <span class="comment">//下一次搜索的起点就是要删除的结点的下一个!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == h)</span><br><span class="line">        &#123;</span><br><span class="line">            h = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;next = px-&gt;next;</span><br><span class="line">            px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归删除</span></span><br><span class="line"><span class="function">Node *<span class="title">Delete_X_v2</span><span class="params">(Node *h, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        Node *px = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(px);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Delete_X_v2(h,x);  <span class="comment">//如果后面还有待删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        h-&gt;next = Delete_X_v2(h-&gt;next, x);   <span class="comment">//递归删除中间的结点</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h3><p>正负数排序</p>
<p>相对位置不变，时间复杂度O(n),不能申请新的空间</p>
<p>算法1：依次摘除负数结点，链接剩下的。成功排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Adjust</span><span class="params">(Node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *first = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的第一个结点</span></span><br><span class="line">    Node *last = <span class="literal">NULL</span>; <span class="comment">//指向摘除后，负数链表的最后一个结点</span></span><br><span class="line"></span><br><span class="line">    Node *px = h; <span class="comment">//指向原链表中“下一个要摘除的结点”</span></span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;<span class="comment">//指向px前面的那个结点</span></span><br><span class="line">    Node *ps = h; <span class="comment">//下一次搜索的起始结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//&quot;查找下一个负数结点&quot;</span></span><br><span class="line">        px = ps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (px)   <span class="comment">//第一次找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (px-&gt;data &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pr = px;</span><br><span class="line">            px = px-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//“查找的结果只有两种情况：要么没有找到，要么找到了”</span></span><br><span class="line">        <span class="keyword">if</span> (px == <span class="literal">NULL</span>)  <span class="comment">//遍历完成，没有找到负数结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//原链表上已经不存在“负数结点”啦</span></span><br><span class="line">            <span class="comment">//这个时候，你需要做的事情是：把负数链表和剩余的</span></span><br><span class="line">            <span class="comment">// 原链表链起来就可以了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last-&gt;next = h;</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            ps = px-&gt;next; <span class="comment">//下一次搜索的起始结点。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//“找到下一个负数结点啦”</span></span><br><span class="line">            <span class="comment">//(1)先把该负数结点从原链表中摘除下来</span></span><br><span class="line">            <span class="keyword">if</span> (px == h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点是原链表中的“第一个结点”</span></span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要摘除的结点不是原链表中的第一个结点</span></span><br><span class="line">                pr-&gt;next = px-&gt;next;</span><br><span class="line">                px-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)把该负数结点按“尾插法”加入到新负数链表中去</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                first = px;</span><br><span class="line">                last = px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; </span><br><span class="line">                last-&gt;next = px;</span><br><span class="line">                last = px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、逆转链表</p>
<ol start="2">
<li> 就地逆置一个单链表<br> 例子:<pre><code> h:  1 5 3 4 
 =&gt;
 h: 4 3 5 1 
</code></pre>
 要求：<pre><code> 不能新申请结点的空间
</code></pre>
</li>
</ol>
<p>​    算法一:<br>​        1. 把原链表上的结点一一(从第一个到最后一个)摘除下来<br>​                2. 把摘除下来的结点，按“头插法”加入到新链表中</p>
<p>​        p 指向新摘除的结点<br>​        </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first =<span class="literal">NULL</span>; <span class="comment">//指向新链表的第一个结点</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (h)</span><br><span class="line">​        &#123;</span><br><span class="line">​            p = h;</span><br><span class="line">​            h = h-&gt;next;</span><br><span class="line">​            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">​            &#123;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line">​            <span class="keyword">else</span></span><br><span class="line">​            &#123;</span><br><span class="line">​                p-&gt;next = first;</span><br><span class="line">​                first = p;</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure>

<p>​    算法二:<br>​        把原链表“一分为二”：<br>​            第一个结点为链表1， h1指向第一个链表的第一个结点<br>​            其余结点为链表2    h2指向后面那个链表的第一个结点</p>
<p>​        只考虑h1和h2这两个结点，逆置，h2放置在h1的前面</p>
<p>​            p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​            h2-&gt;next = h1;<br>​            h1 = h2;<br>​            h2 = p;</p>
<p>​            h1 = h;<br>​            h2 = h-&gt;next ;<br>​            h-&gt;next = NULL;</p>
<p>​            while (h2)<br>​            {<br>​                p = h2-&gt;next; //先保存后面那个链表的第二个结点<br>​                h2-&gt;next = h1;<br>​                h1 = h2;<br>​                h2 = p;</p>
<p>​            }</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	Node*</span><br><span class="line">​	reverse(Node* h)</span><br><span class="line">​	&#123;</span><br><span class="line">​	         h1 = h;</span><br><span class="line">​            h2 = h-&gt;next ;</span><br><span class="line">​            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">while</span> (h2)</span><br><span class="line">​            &#123;</span><br><span class="line">​                p = h2-&gt;next; <span class="comment">//先保存后面那个链表的第二个结点</span></span><br><span class="line">​                h2-&gt;next = h1;</span><br><span class="line">​                h1 = h2; </span><br><span class="line">​                h2 = p;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line">​	</span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>双链表的打印方式可以用递归的方法实现 先递归打印 p-&gt;next，然后打印本身</p>
</blockquote>
]]></content>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事-实训(智能家居系统)</title>
    <url>/2021/06/16/%E6%97%A5%E5%B8%B8%E4%BA%8B-2/</url>
    <content><![CDATA[<p>为期三周的实训告一段落。</p>
<span id="more"></span>

<h1 id="完成智能家居系统"><a href="#完成智能家居系统" class="headerlink" title="完成智能家居系统"></a>完成智能家居系统</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>学习Zigbee 无线局域网 的组网技术。 </p>
<p>开发工具包：Ztack 协议栈  软件：一个下载软件 ，一个编译软件。 以.hex文件烧录到Zigbee模块。外设有：LED灯，温度，湿度检测，按键。</p>
<p>成品:1.一个模块作为适配器，适配器是局域网组网的原点。2、共有三种模式：适配器模式，路由器模式和终端模式  3、适配器和终端组网通信，通过串口打印信息。</p>
<h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p>学习C++基础知识。新知识点：构造函数的知识，编译器优化和不优化的区别以及指令。《Prime C++》看完，内容多而杂。后期提升多敲代码。对C++颇感兴趣</p>
<h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p>学习QT的知识。</p>
<p>重中之重。。看完B站上的QT教程 <a href="https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14">https://www.bilibili.com/video/BV1g4411H78N?t=713&amp;p=14</a> </p>
<p>如今，着重运用的技术有：信号和槽、各种组件类的运用，QT提供的服务(主要存放在.obj文件上)。-&gt;QT程序在Linux环境上的交叉编译，生成可执行文件。传输到GEC6818开发板上运行程序。</p>
<p>总结:QT的基本概念清晰。但是，软肋就是不会折腾。室友夜以继日的卷，明显自己的基本了解完全不行&gt;__&lt; 。 外加美术功底的问题，界面设计实在不太理想。。</p>
<h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><p>多多更新博客，多多上传项目到github，多多折腾</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx那些事</title>
    <url>/2021/06/04/nginx%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="Nginx那些事儿"><a href="#Nginx那些事儿" class="headerlink" title="Nginx那些事儿"></a>Nginx那些事儿</h2><p>nginx简介：<strong>高性能的HTTP</strong>和<strong>反向代理Web服务器</strong>，提供各种服务 IMAP/POP3/SMTP 等等服务。</p>
<span id="more"></span>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>(1)正向代理:在客户端需要配置代理服务器，通过代理服务器进行互联网访问</p>
<p>(2)反向代理：客户端不需要配置 反向代理服务器 。 对外，反向代理服务器和目标是一个服务器</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>QT那些事儿(1)</title>
    <url>/2021/05/15/QT%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-1/</url>
    <content><![CDATA[<h2 id="QT那些事儿（1）"><a href="#QT那些事儿（1）" class="headerlink" title="QT那些事儿（1）"></a>QT那些事儿（1）</h2><h3 id="1、QT是神马？"><a href="#1、QT是神马？" class="headerlink" title="1、QT是神马？"></a>1、QT是神马？</h3><span id="more"></span>

<blockquote>
<p><strong>关于QT的介绍呢，让我们乘上时光机</strong> <a href="https://zhuanlan.zhihu.com/p/140489718">https://zhuanlan.zhihu.com/p/140489718</a> <strong>一探究竟</strong></p>
</blockquote>
<p>QT呢，是C++御用图形用户界面应用程序框架，与 <u><strong>嵌入式Liunx</strong></u>，<strong>C++</strong> 的开发密不可分。</p>
<blockquote>
<p><strong>先学C++基础语法，基本数据类型，两个复合类型，几种主要的语句，类最基本的创建，构造，析构，就可以学Qt，在Qt中逐渐学会类的构建，类的特性，继承，多态等等，学Qt的时候慢慢感受类，能让你对类和面向对象有更深入的理解，而且可以模仿Qt框架类的实现，它本身就是C++的一个类群</strong></p>
</blockquote>
<h3 id="2、面向offer的编程"><a href="#2、面向offer的编程" class="headerlink" title="2、面向offer的编程"></a>2、面向offer的编程</h3><p>作为一名合格的程序员呢，应该有自己的一套核心技术栈，采集与某 app 的职位招聘信息</p>
<p>（1）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6f946ae4f77d3520011f.jpg"></p>
<p>（2）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6fcf6ae4f77d352323b8.jpg"></p>
<p>（3）、</p>
<p><img src="https://pic.imgdb.cn/item/609f6ff26ae4f77d352524d9.jpg"></p>
<p><em><strong>高薪offer冲冲冲</strong> ✌</em></p>
]]></content>
      <tags>
        <tag>QT那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title>日常事</title>
    <url>/2021/05/11/%E6%97%A5%E5%B8%B8%E4%BA%8B/</url>
    <content><![CDATA[<p>冲浪发现的博客</p>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/609a400dd1a9ae528f35806c.png"></p>
<blockquote>
<p><a href="https://wujun234.github.io/">https://wujun234.github.io/</a></p>
</blockquote>
<p>有时候找些想要学的途径，杂七杂八的不好下手，非常好的知识梳理框架，康康大佬是怎么学习的</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之旅(1)</title>
    <url>/2021/05/09/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85-1/</url>
    <content><![CDATA[<h1 id="学习之旅-1"><a href="#学习之旅-1" class="headerlink" title="学习之旅(1)"></a>学习之旅(1)</h1><p>本篇章记录自己的学习生活。至于有多少后序呢，，，，，，</p>
<span id="more"></span>

<p>写博客嘞，找点素材，有时间把博客功能丰富一下。作为一名学习参与者，记录一下近期的学习的晋升之旅</p>
<p><em>现阶段呢，还是以啃书为主。各种书的资源呢，也许我会上传到github</em></p>
<h2 id="1、C-的学习"><a href="#1、C-的学习" class="headerlink" title="1、C++的学习"></a>1、C++的学习</h2><p>先说一下对学习C++的印象哈，语言的学习嘛，多而杂。最近在啃那个《Primer C++》</p>
<p>就这：</p>
<p><img src="https://pic.imgdb.cn/item/6097861cd1a9ae528f259d63.png"></p>
<p>有人会说啊，这个这个语言不就那几个循环啊，条件判断什么的嘛，过一遍就行。这样下去是不行滴昂，比如说，变量声明和定义的区别，作用域的理解啊。。。巴拉巴拉，语言的学习呢，还是要细致一点滴。经过C语言学习的惨痛教训呢(当时没认真听课)，深刻认识到语言的学习要细致入微。这本书呢，还是C++入门级别 &gt;__&lt;，别急，慢慢来，时间多的很。</p>
<blockquote>
<p><a href="https://light-city.club/sc/">https://light-city.club/sc/</a>  ，这个呢，是一个大佬的晋升之路。至于自己能走到哪，看造化吧。  </p>
</blockquote>
<h2 id="2、LeetCode-算法刷题"><a href="#2、LeetCode-算法刷题" class="headerlink" title="2、LeetCode 算法刷题"></a>2、LeetCode 算法刷题</h2><p>比起C++呢，这个篇章没有那么多，那么杂。But,but,真的耗时间。算法嘛，相当于修炼内功了，打好扎实的基础还是很有好处滴</p>
<p><img src="https://pic.imgdb.cn/item/60978afdd1a9ae528f608a6e.png"></p>
<p>这本书呢，是一个Google大佬编的，对我呢还是挺友好的，现在看到了那个分治法。刷题也要先学基本功对不对，进力扣网站，刚开始就整一些动态规划啊，贪心算法巴拉巴拉的名词，一道题刷一天也不是办法对不对。</p>
<h2 id="3、Linux-Unix系统开发的学习"><a href="#3、Linux-Unix系统开发的学习" class="headerlink" title="3、Linux /Unix系统开发的学习"></a>3、Linux /Unix系统开发的学习</h2><p>因为呢，本身是走嵌入式开发学习方向的啊，Linux 的学习必不可少。之前几个学期呢，学了Shell 编程啊，进程开发，通信啊，文件IO什么的。又说呢，学习要细致，来，上干货啃书。</p>
<p><img src="https://pic.imgdb.cn/item/60978d33d1a9ae528f80c0aa.png"></p>
<p>嘶，，822页。但是呢，我之前五一啃完了一本Linux 系统编程。看着目录还行，内容上面都是老熟人了，得空就啃了。</p>
<h2 id="4、数据结构的学习"><a href="#4、数据结构的学习" class="headerlink" title="4、数据结构的学习"></a>4、数据结构的学习</h2><p>3月份呢，过了一遍数据结构的书，但是呢，现在基本忘光。二刷，不就树啊，图什么的。</p>
<h2 id="5、英语"><a href="#5、英语" class="headerlink" title="5、英语"></a>5、英语</h2><p>6月份考六级了，现在呢，单词准备过第二遍，刷十几套试卷什么的，这不，上午刚了<u>七十几个</u>单词 ，不是吹的，主要是第二遍，速度比较抓紧一点。刷试卷还是要刷滴，英语考试对我来说就是考题感，感觉刷上来了什么都好说。</p>
<p>完，暂时就这些，后期呢，准备搞一下网络，单片机，ARM开发的复习，还有搞一下QT的学习。下午的话搞一下这个博客的使用，再看一下科目四，星期二就要拿证了，芜湖~</p>
]]></content>
      <tags>
        <tag>学习之旅</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索算法</title>
    <url>/2021/05/08/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><span id="more"></span>

<p>在搜索到一个新的节点时，立即对该新节点进行遍历，需要依靠先入后出的栈来实现，也可以通过与栈等价的递归来实现。也可以用来检测环路。拓扑排序可以判断是否有环路。</p>
<h3 id="1、最大水洼求值"><a href="#1、最大水洼求值" class="headerlink" title="1、最大水洼求值"></a>1、最大水洼求值</h3><p>Input: [[1,0,1,1,0,1,0,1], </p>
<p>​           [1,0,1,1,0,1,1,1],</p>
<p>​           [0,0,0,0,0,0,0,1]]                    Output: 6</p>
<h4 id="递归思路："><a href="#递归思路：" class="headerlink" title="递归思路："></a>递归思路：</h4><p>​           (1)  分为主函数( 用于遍历判断” 1 “ 的位置，开始递归搜索 )和辅函数( 用于递归搜索”1”的位置)</p>
<p>​           (2) 辅函数中逢”1” 置 “0” ，临近水洼置”0” , 避免重复判断</p>
<p>​           (3)递归搜索时，边界(矩阵越界)判断方法两种：先判断是否越界再开始搜索（即判断放在调用 递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合 法（即判断放在辅函数第一行）。</p>
<p>第一种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//判断上下左右的位置</span></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;   <span class="comment">//遍历二维数组得到陷入递归函数的调用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;   <span class="comment">//判断水洼陷入递归函数调用</span></span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));  <span class="comment">//比较函数，得到最大数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y, area = <span class="number">1</span>;   <span class="comment">//每一次递归(取到一个&quot;1&quot;)都会return 一个area,最后累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];   <span class="comment">//取四个方向的递归</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            area += <span class="built_in">dfs</span>(grid, x, y);   <span class="comment">//累计水洼数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种判断边界的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>() || grid[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, <span class="built_in">dfs</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= grid.<span class="built_in">size</span>() ||c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c) + <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>) + <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的写法："><a href="#栈的写法：" class="headerlink" title="栈的写法："></a>栈的写法：</h4><p>关于图片加载的问题：上传到github ,下一篇开始采用聚合图床上传</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B0%B4%E6%B4%BC.png" alt="水洼"></p>
<p>思路：针对每一个入栈的元素 [r , c] 都进行4次的坐标入栈。 local_area 的累加都在判断中间。max 的 取值都在主循环</p>
<h3 id="2、海流方向"><a href="#2、海流方向" class="headerlink" title="2、海流方向"></a>2、海流方向</h3><p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E6%B5%B7%E6%B5%81%E6%96%B9%E5%90%91.png"></p>
<p>思路：因此我们可以反过来想，从两个大洋开始向上流，这样我们 只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋 向上流都能到达的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_p</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到太平洋</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">can_reach_a</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));   <span class="comment">//是否能流到大西洋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, i, <span class="number">0</span>);    <span class="comment">//左边开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, i, n - <span class="number">1</span>);  <span class="comment">//从右边开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_p, <span class="number">0</span>, i);    <span class="comment">//从上面开始搜索</span></span><br><span class="line">        <span class="built_in">dfs</span>(matrix, can_reach_a, m - <span class="number">1</span>, i);   <span class="comment">//从下面开始搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_reach_p[i][j] &amp;&amp; can_reach_a[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);      <span class="comment">//两大洋都能流到，压栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; can_reach,<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (can_reach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    can_reach[r][c] = <span class="literal">true</span>;   <span class="comment">//满足条件(找到最高点即退出循环，可以先置&quot;true&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        x = r + direction[i], y = c + direction[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>()</span><br><span class="line">            &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">            matrix[r][c] &lt;= matrix[x][y]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(matrix, can_reach, x, y);  <span class="comment">//判断条件为：边界判断以及最高点条件判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><blockquote>
<p>[修改当前节点状态]→[递归子节点]→[回改当前节点 状态]。         此路不通，修改之前一步的状态，回退一步，继续搜索。</p>
</blockquote>
<h3 id="1、全排列"><a href="#1、全排列" class="headerlink" title="1、全排列"></a>1、全排列</h3><p>[1,2,3]  的可能排列方式 ，题解可以采用树形结构：</p>
<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E5%85%A8%E6%8E%92%E5%88%97.png" alt="全排列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> level, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, level+<span class="number">1</span>, ans); <span class="comment">// 递归子节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[level]); <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>1、level 为树的层次，递归的终止条件为：level == nums.size() -1,到树底部终结递归</p>
<p>2、for循环中的 level 和 level+1 ，每次递归都会随着树的深度增加而发生变化，但是始终没有改变值。(栈空间的临时存储)。</p>
<p>3、过程模拟:  第一棵树： i = 0,level=0 , 即[1,2,3],进行交换。子树里面,level增加，i又要从level到nums.size()-1来分配情况。第一个确定，依据 level 来交换情况</p>
<p>4、i+1 的时候要回退一步(回到根节点来进行回溯)。在修改结点，递归后面回退根节点的状态，即swap(nums[i],nums[level]);</p>
<h3 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h3><p>Input: n = 4, k = 2 </p>
<p>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;  <span class="comment">//最后输出数据</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">comb</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(ans, comb, count, <span class="number">1</span>, n, k);  <span class="comment">//count 计算深度,comb临时两个[a,b]数组，&quot;1&quot;为初始位置开始也可看做深度</span></span><br><span class="line">    <span class="comment">//count作为数组的编号取值</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; comb, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  pos, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(comb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; ++i) &#123;</span><br><span class="line">        comb[count++] = i; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">        <span class="built_in">backtracking</span>(ans, comb, count, i + <span class="number">1</span>, n, k); <span class="comment">// 递归子节点</span></span><br><span class="line">        --count; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Goku404/PicGo/main/img/%E7%BB%84%E5%90%88.png"></p>
<h3 id="3、字符串搜索"><a href="#3、字符串搜索" class="headerlink" title="3、字符串搜索"></a>3、字符串搜索</h3><p>Input: word = “ABCCED”, board = [[’A’,’B’,’C’,’E’],</p>
<p>​                                                        [’S’,’F’,’C’,’S’], </p>
<p>​                                                        [’A’,’D’,’E’,’E’]] </p>
<p>Output: true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="keyword">bool</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  &amp; find, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[i][j] || find || board[i][j] != word[pos]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改当前节点状态</span></span><br><span class="line">    <span class="comment">// 递归子节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>; <span class="comment">// 回改当前节点状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>广度优先搜索(BFS)采用先进先出的队列结构，深度优先采用先进后出的栈结构</p>
<h3 id="1、两个岛屿最小距离"><a href="#1、两个岛屿最小距离" class="headerlink" title="1、两个岛屿最小距离"></a>1、两个岛屿最小距离</h3><p>(深度优先查找一个岛屿的位置，全部置为”2” , 接着从岛屿的各个周围遍历，直到找到另一个岛屿，即是最短距离)</p>
<p>Input: </p>
<p>​          [[1,1,1,1,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,0,1,0,1], </p>
<p>​            [1,0,0,0,1], </p>
<p>​            [1,1,1,1,1]] </p>
<p>Output: 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; direction&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; points;</span><br><span class="line">    <span class="comment">// dfs寻找第一个岛屿，并把1全部赋值为2</span></span><br><span class="line">    <span class="keyword">bool</span> flipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flipped) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(points, grid, m, n, i, j);</span><br><span class="line">                flipped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs寻找第二个岛屿，并把过程中经过的0赋值为2</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!points.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();   <span class="comment">//n个临近海域搜索，完结后进入第二级海域</span></span><br><span class="line">        <span class="keyword">while</span> (n_points--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = points.<span class="built_in">front</span>();</span><br><span class="line">            points.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                x = r + direction[k], y = c + direction[k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    points.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n</span></span></span><br><span class="line"><span class="function"><span class="params">         , <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == m || j == n || grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        points.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(points, grid, m, n, i, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--points队列里面存的是临近第一个小岛的海域-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>1、有序数列的查找</p>
<p>返回元素第一次出现的位置和最后一次出现的位置</p>
<span id="more"></span>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mylower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myupper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> lower = <span class="built_in">mylower_bound</span>(nums, target);</span><br><span class="line">	<span class="keyword">int</span> upper = <span class="built_in">myupper_bound</span>(nums, target) - <span class="number">1</span>; <span class="comment">// 这里需要减1位</span></span><br><span class="line">	<span class="keyword">if</span> (lower == nums.<span class="built_in">size</span>() || nums[lower] != target) &#123;</span><br><span class="line">		<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;lower, upper&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2 = <span class="built_in">searchRange</span>(v1,i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;含有 7 的区间为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; v2.<span class="built_in">size</span>(); j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v2[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、二分查找的开区间和闭区间"><a href="#2、二分查找的开区间和闭区间" class="headerlink" title="2、二分查找的开区间和闭区间"></a>2、二分查找的开区间和闭区间</h3><p>一般查找分为 左闭右开 和 左闭右闭两种情况：</p>
<p><a href="https://blog.csdn.net/blue_coffeei/article/details/91476091">https://blog.csdn.net/blue_coffeei/article/details/91476091</a></p>
<h3 id="3、牛顿迭代法（开平方）"><a href="#3、牛顿迭代法（开平方）" class="headerlink" title="3、牛顿迭代法（开平方）"></a>3、牛顿迭代法（开平方）</h3><p>其公式为 xn+1 = xn − f (xn)/ f ′ (xn)。给 定 f (x) = x 2 − a = 0，这里的迭代公式为 xn+1 = (xn + a/xn)/2，其代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> x = a;</span><br><span class="line">		<span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">			x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、旋转数组查找法"><a href="#4、旋转数组查找法" class="headerlink" title="4、旋转数组查找法"></a>4、旋转数组查找法</h3><p>1.查找旋转数组的最小值</p>
<p>Input: nums = [2,5,6,0,0,1,2],</p>
<p>思路：三种情况</p>
<p>1、nums [mid] &lt; nums [r] =&gt; mid 位于右区间，右区间有序</p>
<p>2、nums[mid] &gt; nums [r] =&gt; mid 位于左区间，左区间有序</p>
<p>3、nums[mid] = nums[r] =&gt; 重复的值，r - -</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>,<span class="built_in">len</span>(numbers-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> left&lt;right:</span><br><span class="line">     mid = (left+right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> numbers[mid] &gt; numbers[right]; <span class="string">&quot;&quot;&quot;位于左区间&quot;&quot;&quot;</span></span><br><span class="line">       left = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">elif</span> numbers[mid] &lt; numbers[right]; <span class="string">&quot;&quot;&quot;位于右区间&quot;&quot;&quot;</span></span><br><span class="line">       right = mid;    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> numbers[left]</span><br></pre></td></tr></table></figure>

<!--因为是查找最小值，区间的收缩会不一样-->]]></content>
      <tags>
        <tag>力扣算法-C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/05/hello-world/</url>
    <content><![CDATA[<p>临阵磨枪一波，搞个博客。</p>
<blockquote>
<p>入坑教程：<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a></p>
</blockquote>
]]></content>
  </entry>
</search>
